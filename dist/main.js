(()=>{var e,t,r={465:e=>{function t(e){return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}))}t.keys=()=>[],t.resolve=t,t.id=465,e.exports=t},785:(e,t,r)=>{var o={"./memory-adapter.js":[225,225]};function i(e){if(!r.o(o,e))return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}));var t=o[e],i=t[0];return r.e(t[1]).then((()=>r(i)))}i.keys=()=>Object.keys(o),i.id=785,e.exports=i},1:(e,t,r)=>{"use strict";r.d(t,{t:()=>a});var o=r(403);class i extends o.P{}class n{_services=new Map;get(e,...t){if(!e||"function"!=typeof e)throw new i("The first argument of ServicesContainer.get must be a class constructor, but %v given.",e);let r=this._services.get(e);return!r||t.length?(r="prototype"in e&&e.prototype instanceof a?new e(this,...t):new e(...t),this._services.set(e,r)):"function"==typeof r&&(r=r(),this._services.set(e,r)),r}has(e){return this._services.has(e)}add(e,...t){if(!e||"function"!=typeof e)throw new i("The first argument of ServicesContainer.add must be a class constructor, but %v given.",e);return this._services.set(e,(()=>e.prototype instanceof a?new e(this,...t):new e(...t))),this}use(e,...t){if(!e||"function"!=typeof e)throw new i("The first argument of ServicesContainer.use must be a class constructor, but %v given.",e);const r=e.prototype instanceof a?new e(this,...t):new e(...t);return this._services.set(e,r),this}}class a{container;constructor(e=void 0){this.container=e instanceof n?e:new n}getService(e,...t){return this.container.get(e,...t)}hasService(e){return this.container.has(e)}addService(e,...t){return this.container.add(e,...t),this}useService(e,...t){return this.container.use(e,...t),this}}},403:(e,t,r)=>{"use strict";r.d(t,{P:()=>i});var o=r(911);class i extends Error{constructor(e=void 0,...t){super(null!=e?(0,o.W)(e,...t):void 0)}}},911:(e,t,r)=>{"use strict";function o(e){return null==e?String(e):"string"==typeof e?`"${e}"`:"number"==typeof e||"boolean"==typeof e?String(e):e.constructor&&e.constructor.name?e.constructor.name:"object"==typeof e&&null==e.constructor?"Object":String(e)}r.d(t,{W:()=>n});const i=", ";function n(e){e instanceof Date?e=e.toISOString():"string"!=typeof e&&(e=String(e));const t=Array.prototype.slice.call(arguments,1);return t.length&&(e=e.replace(/(%?)(%([sdjvl]))/g,(function(e,r,n,a){let s=t.shift();switch(a){case"s":s=String(s);break;case"d":s=Number(s);break;case"j":s=JSON.stringify(s);break;case"v":s=o(s);break;case"l":l=s,s=Array.isArray(l)&&l.length?l.map(o).join(i):o(l)}var l;return r?(t.unshift(s),e):s}))),t.length&&(e+=" "+t.join(" ")),""+e.replace(/%{2,2}/g,"%")}},895:(e,t,r)=>{"use strict";r.d(t,{L:()=>d});var o=r(1),i=r(774),n=r(202),a=r(524);class s extends o.t{decorate(e){if(!(e&&e instanceof d))throw new a.R("A first argument of InclusionDecorator.decorate must be an Adapter instance, but %v given.",e);const t=e.getService(n.A9),r=(...e)=>t.includeTo(...e),o=e.create;e.create=async function(e,t,i){const n=await o.call(this,e,t,i);return i&&"object"==typeof i&&i.include&&await r([n],e,i.include),n};const i=e.replaceById;e.replaceById=async function(e,t,o,n){const a=await i.call(this,e,t,o,n);return n&&"object"==typeof n&&n.include&&await r([a],e,n.include),a};const s=e.patchById;e.patchById=async function(e,t,o,i){const n=await s.call(this,e,t,o,i);return i&&"object"==typeof i&&i.include&&await r([n],e,i.include),n};const l=e.find;e.find=async function(e,t){const o=await l.call(this,e,t);return t&&"object"==typeof t&&t.include&&await r(o,e,t.include),o};const c=e.findById;e.findById=async function(e,t,o){const i=await c.call(this,e,t,o);return o&&"object"==typeof o&&o.include&&await r([i],e,o.include),i}}}var l=r(606);class c extends o.t{decorate(e){if(!(e&&e instanceof d))throw new a.R("A first argument of DefaultValuesDecorator.decorate must be an Adapter instance, but %v given.",e);const t=e.getService(l.r0),r=(...e)=>t.setDefaultValuesToEmptyProperties(...e),o=e.create;e.create=function(e,t,i){return t=r(e,t),o.call(this,e,t,i)};const i=e.replaceById;e.replaceById=function(e,t,o,n){return o=r(e,o),i.call(this,e,t,o,n)};const n=e.patchById;e.patchById=function(e,t,o,i){return o=r(e,o,!0),n.call(this,e,t,o,i)};const s=e.find;e.find=async function(e,t){return(await s.call(this,e,t)).map((t=>r(e,t)))};const c=e.findById;e.findById=async function(e,t,o){const i=await c.call(this,e,t,o);return r(e,i)}}}class h extends o.t{decorate(e){if(!(e&&e instanceof d))throw new a.R("A first argument of DataSanitizingDecorator.decorate must be an Adapter instance, but %v given.",e);const t=e.getService(l.Qv),r=(...e)=>t.sanitize(...e),o=e.create;e.create=async function(e,t,i){return t=r(e,t),o.call(this,e,t,i)};const i=e.replaceById;e.replaceById=async function(e,t,o,n){return o=r(e,o),i.call(this,e,t,o,n)};const n=e.patchById;e.patchById=async function(e,t,o,i){return o=r(e,o),n.call(this,e,t,o,i)}}}class f extends o.t{decorate(e){if(!(e&&e instanceof d))throw new a.R("A first argument of DataValidationDecorator.decorate must be an Adapter instance, but %v given.",e);const t=e.create;e.create=function(e,r,o){return this.getService(l.o7).validate(e,r),t.call(this,e,r,o)};const r=e.replaceById;e.replaceById=function(e,t,o,i){return this.getService(l.o7).validate(e,o),r.call(this,e,t,o,i)};const o=e.patchById;e.patchById=function(e,t,r,i){return this.getService(l.o7).validate(e,r,!0),o.call(this,e,t,r,i)}}}class p extends o.t{decorate(e){if(!(e&&e instanceof d))throw new a.R("A first argument of FieldsFilteringDecorator.decorate must be an Adapter instance, but %v given.",e);const t=e.getService(n.NF),r=(...e)=>t.filter(...e),o=e.create;e.create=async function(e,t,i){let n=await o.call(this,e,t,i);return i&&"object"==typeof i&&i.fields&&(n=r(n,e,i.fields)),n};const i=e.replaceById;e.replaceById=async function(e,t,o,n){let a=await i.call(this,e,t,o,n);return n&&"object"==typeof n&&n.fields&&(a=r(a,e,n.fields)),a};const s=e.patchById;e.patchById=async function(e,t,o,i){let n=await s.call(this,e,t,o,i);return i&&"object"==typeof i&&i.fields&&(n=r(n,e,i.fields)),n};const l=e.find;e.find=async function(e,t){let o=await l.call(this,e,t);return t&&"object"==typeof t&&t.fields&&(o=r(o,e,t.fields)),o};const c=e.findById;e.findById=async function(e,t,o){let i=await c.call(this,e,t,o);return o&&"object"==typeof o&&o.fields&&(i=r(i,e,o.fields)),i}}}class d extends o.t{_settings;get settings(){return this._settings}constructor(e=void 0,t=void 0){super(e),this._settings=t,this.constructor!==d&&(this.getService(f).decorate(this),this.getService(h).decorate(this),this.getService(c).decorate(this),this.getService(p).decorate(this),this.getService(s).decorate(this))}create(e,t,r=void 0){throw new i.n("%s.create is not implemented.",this.constructor.name)}replaceById(e,t,r,o=void 0){throw new i.n("%s.replaceById is not implemented.",this.constructor.name)}patchById(e,t,r,o=void 0){throw new i.n("%s.patchById is not implemented.",this.constructor.name)}find(e,t=void 0){throw new i.n("%s.find is not implemented.",this.constructor.name)}findById(e,t,r=void 0){throw new i.n("%s.findById is not implemented.",this.constructor.name)}delete(e,t=void 0){throw new i.n("%s.delete is not implemented.",this.constructor.name)}deleteById(e,t){throw new i.n("%s.deleteById is not implemented.",this.constructor.name)}exists(e,t){throw new i.n("%s.exists is not implemented.",this.constructor.name)}count(e,t=void 0){throw new i.n("%s.count is not implemented.",this.constructor.name)}}},949:(e,t,r)=>{"use strict";r.d(t,{L1:()=>o.L,iq:()=>a,gO:()=>c});var o=r(895),i=r(1),n=r(524);class a extends i.t{async loadByName(e,t=void 0){if(!e||"string"!=typeof e)throw new n.R("The adapter name must be a non-empty String, but %v given.",e);let o;try{o=s(await r(785)(`./${e}-adapter.js`))}catch(e){}if(!o)try{o=s(await r(465)(`./node-repository-${e}-adapter`))}catch(e){}if(!o)throw new n.R("The adapter %v is not found.",e);return new o(this.container,t)}}function s(e){let t;if(e&&"object"==typeof e&&!Array.isArray(e)){for(const r of Object.values(e))if("function"==typeof r&&r.prototype instanceof o.L){t=r;break}return t}}var l=r(606);class c extends i.t{_adapters={};async getAdapter(e){let t=this._adapters[e];if(t)return t;const r=this.getService(l.D5).getDatasource(e),o=r.adapter;return t=await this.getService(a).loadByName(o,r),this._adapters[e]=t,t}}},606:(e,t,r)=>{"use strict";r.d(t,{Dp:()=>f,g:()=>s,Jo:()=>R,VN:()=>m,D5:()=>h,Qv:()=>b,o7:()=>v,r0:()=>p,De:()=>w,nc:()=>d,wK:()=>g,uT:()=>o,Qn:()=>a});const o={BELONGS_TO:"belongsTo",HAS_ONE:"hasOne",HAS_MANY:"hasMany",REFERENCES_MANY:"referencesMany"};var i=r(1),n=r(524);class a extends i.t{validate(e,t){if(!e||"string"!=typeof e)throw new n.R("A first argument of RelationsDefinitionValidator.validate should be a non-empty String, but %v given.",e);if(!t||"object"!=typeof t||Array.isArray(t))throw new n.R('The provided option "relations" of the model %v should be an Object, but %v given.',e,t);Object.keys(t).forEach((r=>{const o=t[r];this._validateRelation(e,r,o)}))}_validateRelation(e,t,r){if(!e||"string"!=typeof e)throw new n.R("A first argument of RelationsDefinitionValidator._validateRelation should be a non-empty String, but %v given.",e);if(!t||"string"!=typeof t)throw new n.R("The relation name of the model %v should be a non-empty String, but %v given.",e,t);if(!r||"object"!=typeof r||Array.isArray(r))throw new n.R("The relation %v of the model %v should be an Object, but %v given.",t,e,r);if(!r.type||!Object.values(o).includes(r.type))throw new n.R('The relation %v of the model %v requires the option "type" to have one of relation types: %l, but %v given.',t,e,Object.values(o),r.type);this._validateBelongsTo(e,t,r),this._validateHasOne(e,t,r),this._validateHasMany(e,t,r),this._validateReferencesMany(e,t,r)}_validateBelongsTo(e,t,r){if(r.type===o.BELONGS_TO)if(r.polymorphic){if("boolean"!=typeof r.polymorphic)throw new n.R('The relation %v of the model %v has the type "belongsTo", so it expects the option "polymorphic" to be a Boolean, but %v given.',t,e,r.polymorphic);if(r.foreignKey&&"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v is a polymorphic "belongsTo" relation, so it expects the provided option "foreignKey" to be a String, but %v given.',t,e,r.foreignKey);if(r.discriminator&&"string"!=typeof r.discriminator)throw new n.R('The relation %v of the model %v is a polymorphic "belongsTo" relation, so it expects the provided option "discriminator" to be a String, but %v given.',t,e,r.discriminator)}else{if(!r.model||"string"!=typeof r.model)throw new n.R('The relation %v of the model %v has the type "belongsTo", so it requires the option "model" to be a non-empty String, but %v given.',t,e,r.model);if(r.foreignKey&&"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v has the type "belongsTo", so it expects the provided option "foreignKey" to be a String, but %v given.',t,e,r.foreignKey);if(r.discriminator)throw new n.R('The relation %v of the model %v is a non-polymorphic "belongsTo" relation, so it should not have the option "discriminator" to be provided.',t,e)}}_validateHasOne(e,t,r){if(r.type===o.HAS_ONE){if(!r.model||"string"!=typeof r.model)throw new n.R('The relation %v of the model %v has the type "hasOne", so it requires the option "model" to be a non-empty String, but %v given.',t,e,r.model);if(r.polymorphic)if("string"==typeof r.polymorphic){if(r.foreignKey)throw new n.R('The relation %v of the model %v has the option "polymorphic" with a String value, so it should not have the option "foreignKey" to be provided.',t,e);if(r.discriminator)throw new n.R('The relation %v of the model %v has the option "polymorphic" with a String value, so it should not have the option "discriminator" to be provided.',t,e)}else{if("boolean"!=typeof r.polymorphic)throw new n.R('The relation %v of the model %v has the type "hasOne", so it expects the provided option "polymorphic" to be a String or a Boolean, but %v given.',t,e,r.polymorphic);if(!r.foreignKey||"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v has the option "polymorphic" with "true" value, so it requires the option "foreignKey" to be a non-empty String, but %v given.',t,e,r.foreignKey);if(!r.discriminator||"string"!=typeof r.discriminator)throw new n.R('The relation %v of the model %v has the option "polymorphic" with "true" value, so it requires the option "discriminator" to be a non-empty String, but %v given.',t,e,r.discriminator)}else{if(!r.foreignKey||"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v has the type "hasOne", so it requires the option "foreignKey" to be a non-empty String, but %v given.',t,e,r.foreignKey);if(r.discriminator)throw new n.R('The relation %v of the model %v is a non-polymorphic "hasOne" relation, so it should not have the option "discriminator" to be provided.',t,e)}}}_validateHasMany(e,t,r){if(r.type===o.HAS_MANY){if(!r.model||"string"!=typeof r.model)throw new n.R('The relation %v of the model %v has the type "hasMany", so it requires the option "model" to be a non-empty String, but %v given.',t,e,r.model);if(r.polymorphic)if("string"==typeof r.polymorphic){if(r.foreignKey)throw new n.R('The relation %v of the model %v has the option "polymorphic" with a String value, so it should not have the option "foreignKey" to be provided.',t,e);if(r.discriminator)throw new n.R('The relation %v of the model %v has the option "polymorphic" with a String value, so it should not have the option "discriminator" to be provided.',t,e)}else{if("boolean"!=typeof r.polymorphic)throw new n.R('The relation %v of the model %v has the type "hasMany", so it expects the provided option "polymorphic" to be a String or a Boolean, but %v given.',t,e,r.polymorphic);if(!r.foreignKey||"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v has the option "polymorphic" with "true" value, so it requires the option "foreignKey" to be a non-empty String, but %v given.',t,e,r.foreignKey);if(!r.discriminator||"string"!=typeof r.discriminator)throw new n.R('The relation %v of the model %v has the option "polymorphic" with "true" value, so it requires the option "discriminator" to be a non-empty String, but %v given.',t,e,r.discriminator)}else{if(!r.foreignKey||"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v has the type "hasMany", so it requires the option "foreignKey" to be a non-empty String, but %v given.',t,e,r.foreignKey);if(r.discriminator)throw new n.R('The relation %v of the model %v is a non-polymorphic "hasMany" relation, so it should not have the option "discriminator" to be provided.',t,e)}}}_validateReferencesMany(e,t,r){if(r.type===o.REFERENCES_MANY){if(!r.model||"string"!=typeof r.model)throw new n.R('The relation %v of the model %v has the type "referencesMany", so it requires the option "model" to be a non-empty String, but %v given.',t,e,r.model);if(r.foreignKey&&"string"!=typeof r.foreignKey)throw new n.R('The relation %v of the model %v has the type "referencesMany", so it expects the provided option "foreignKey" to be a String, but %v given.',t,e,r.foreignKey);if(r.discriminator)throw new n.R('The relation %v of the model %v has the type "referencesMany", so it should not have the option "discriminator" to be provided.',t,e)}}}const s={ANY:"any",STRING:"string",NUMBER:"number",BOOLEAN:"boolean",ARRAY:"array",OBJECT:"object"};var l=r(390),c=r(918);class h extends i.t{_datasources={};_models={};addDatasource(e){this.getService(R).validate(e);const t=e.name;if(t in this._datasources)throw new n.R("The datasource %v is already defined.",t);this._datasources[t]=e}hasDatasource(e){return Boolean(this._datasources[e])}getDatasource(e){const t=this._datasources[e];if(!t)throw new n.R("The datasource %v is not defined.",e);return t}addModel(e){this.getService(w).validate(e);const t=e.name;if(t in this._models)throw new n.R("The model %v is already defined.",t);this._models[t]=e}hasModel(e){return Boolean(this._models[e])}getModel(e){const t=this._models[e];if(!t)throw new n.R("The model %v is not defined.",e);return t}}const f="id";class p extends i.t{getPrimaryKeyAsPropertyName(e){const t=this.getPropertiesDefinitionInBaseModelHierarchy(e),r=Object.keys(t).filter((e=>{const r=t[e];return r&&"object"==typeof r&&r.primaryKey}));if(r.length<1){if(Object.keys(t).includes(f))throw new n.R('The property name %v of the model %v is defined as a regular property. In this case, a primary key should be defined explicitly. Do use the option "primaryKey" to specify the primary key.',f,e);return f}return r[0]}getPrimaryKeyAsColumnName(e){const t=this.getPrimaryKeyAsPropertyName(e);let r;try{r=this.getColumnNameByPropertyName(e,t)}catch(e){if(!(e instanceof n.R))throw e}return void 0===r?t:r}getTableNameByModelName(e){return this.getService(h).getModel(e).tableName??e}getColumnNameByPropertyName(e,t){const r=this.getPropertiesDefinitionInBaseModelHierarchy(e)[t];if(!r)throw new n.R("The model %v does not have the property %v.",e,t);return r&&"object"==typeof r?r.columnName??t:t}getDefaultPropertyValue(e,t){const r=this.getPropertiesDefinitionInBaseModelHierarchy(e)[t];if(!r)throw new n.R("The model %v does not have the property %v.",e,t);if(r&&"object"==typeof r)return r.default instanceof Function?r.default():r.default}setDefaultValuesToEmptyProperties(e,t,r=!1){const o=this.getPropertiesDefinitionInBaseModelHierarchy(e),i=r?Object.keys(t):Object.keys(o),n=(0,l.X)(t);return i.forEach((t=>{if(null!=n[t])return;const r=o[t];r&&"object"==typeof r&&void 0!==r.default&&(n[t]=this.getDefaultPropertyValue(e,t))})),n}convertPropertyNamesToColumnNames(e,t){const r=this.getPropertiesDefinitionInBaseModelHierarchy(e),o=Object.keys(r),i=(0,l.X)(t);return o.forEach((t=>{if(!(t in i))return;const r=this.getColumnNameByPropertyName(e,t);if(t===r)return;const o=i[t];delete i[t],i[r]=o})),i}convertColumnNamesToPropertyNames(e,t){const r=this.getPropertiesDefinitionInBaseModelHierarchy(e),o=Object.keys(r),i=(0,l.X)(t);return o.forEach((t=>{const r=this.getColumnNameByPropertyName(e,t);if(!(r in i)||r===t)return;const o=i[r];delete i[r],i[t]=o})),i}getDataTypeByPropertyName(e,t){const r=this.getPropertiesDefinitionInBaseModelHierarchy(e)[t];if(!r){if(this.getPrimaryKeyAsPropertyName(e)===t)return s.ANY;throw new n.R("The model %v does not have the property %v.",e,t)}return"string"==typeof r?r:r.type}getOwnPropertiesDefinitionOfPrimaryKeys(e){const t=this.getService(h).getModel(e).properties??{};return Object.keys(t).filter((e=>{const r=t[e];return"object"==typeof r&&r.primaryKey})).reduce(((e,r)=>({...e,[r]:t[r]})),{})}getOwnPropertiesDefinitionWithoutPrimaryKeys(e){const t=this.getService(h).getModel(e).properties??{};return Object.keys(t).reduce(((e,r)=>{const o=t[r];return"object"==typeof o&&o.primaryKey?e:{...e,[r]:o}}),{})}getPropertiesDefinitionInBaseModelHierarchy(e){let t={},r={};const o=(e,i=void 0)=>{if(e===i)throw new n.R("The model %v has a circular inheritance.",e);0===Object.keys(r).length&&(r=this.getOwnPropertiesDefinitionOfPrimaryKeys(e),t={...t,...r});const a=this.getOwnPropertiesDefinitionWithoutPrimaryKeys(e);t={...a,...t};const s=this.getService(h).getModel(e);s.base&&o(s.base,e)};return o(e),t}getOwnRelationsDefinition(e){return this.getService(h).getModel(e).relations??{}}getRelationsDefinitionInBaseModelHierarchy(e){let t={};const r=(e,o=void 0)=>{if(e===o)throw new n.R("The model %v has a circular inheritance.",e);const i=this.getService(h).getModel(e),a=i.relations??{};t={...a,...t},i.base&&r(i.base,e)};return r(e),t}getRelationDefinitionByName(e,t){const r=this.getRelationsDefinitionInBaseModelHierarchy(e),o=Object.keys(r);let i;for(const e of o)if(e===t){i=r[e];break}if(!i)throw new n.R("The model %v does not have relation name %v.",e,t);return i}excludeObjectKeysByRelationNames(e,t){if(!t||"object"!=typeof t||Array.isArray(t))throw new n.R("The second argument of ModelDefinitionUtils.excludeObjectKeysByRelationNames must be an Object, but %v given.",t);const r=this.getRelationsDefinitionInBaseModelHierarchy(e),o=Object.keys(r);return(0,c.H)(t,o)}}class d extends i.t{validate(e,t){const r=Object.keys(t).filter((e=>{const r=t[e];return r&&"object"==typeof r&&r.primaryKey}));if(r.length<1){if(Object.keys(t).includes(f))throw new n.R('The property name %v of the model %v is defined as a regular property. In this case, a primary key should be defined explicitly. Do use the option "primaryKey" to specify the primary key.',f,e);return}if(r.length>1)throw new n.R("The model definition %v should not have multiple primary keys, but %v keys given.",e,r.length);const o=r[0],i=t[o];if(i&&"object"==typeof i&&void 0!==i.default)throw new n.R("Do not specify a default value for the primary key %v of the model %v.",o,e)}}var u=r(110),y=r(697);class v extends i.t{validate(e,t,r=!1){if(!(0,y.S)(t))throw new n.R("The data of the model %v must be an Object, but %v given.",e,t);const o=this.getService(p).getPropertiesDefinitionInBaseModelHierarchy(e);Object.keys(r?t:o).forEach((r=>{const i=o[r];i&&this.validatePropertyValue(e,r,i,t[r])}))}validatePropertyValue(e,t,r,o){if(null==o){if("string"==typeof r||!Boolean(r.required))return;throw new n.R("The property %v of the model %v is required, but %v given.",t,e,o)}this._validatePropertyValueType(e,t,r,o)}_validatePropertyValueType(e,t,r,o,i=!1){let a;a=i?"object"==typeof r?r.itemType??s.ANY:s.ANY:"string"!=typeof r?r.type:r;const l=r=>{const a=i?"The array property %v of the model %v must have %s element, but %s given.":"The property %v of the model %v must have %s, but %s given.",s=(0,u.F)(o)??typeof o;return new n.R(a,t,e,r,s)};switch(a){case s.STRING:if("string"!=typeof o)throw l("a String");break;case s.NUMBER:if("number"!=typeof o)throw l("a Number");break;case s.BOOLEAN:if("boolean"!=typeof o)throw l("a Boolean");break;case s.ARRAY:if(!Array.isArray(o))throw l("an Array");o.forEach((o=>this._validatePropertyValueType(e,t,r,o,!0)));break;case s.OBJECT:if(!(0,y.S)(o))throw l("an Object");"object"==typeof r&&r.model&&this.validate(r.model,o)}}}class m extends i.t{validate(e,t){if(!e||"string"!=typeof e)throw new n.R("A first argument of DefaultValuesDefinitionValidator.validate should be a non-empty String, but %v given.",e);if(!t||"object"!=typeof t||Array.isArray(t))throw new n.R('The provided option "properties" of the model %v should be an Object, but %v given.',e,t);Object.keys(t).forEach((r=>{const o=t[r];if("string"==typeof o)return;if(!("default"in o))return;const i=o.default instanceof Function?o.default():o.default;try{this.getService(v).validatePropertyValue(e,r,o,i)}catch(e){if(e instanceof n.R)throw new n.R(`A default value is invalid. ${e.message}`);throw e}}))}}class g extends i.t{validate(e,t){if(!e||"string"!=typeof e)throw new n.R("A first argument of PropertiesDefinitionValidator.validate should be a non-empty String, but %v given.",e);if(!t||"object"!=typeof t||Array.isArray(t))throw new n.R('The provided option "properties" of the model %v should be an Object, but %v given.',e,t);Object.keys(t).forEach((r=>{const o=t[r];this._validateProperty(e,r,o)})),this.getService(d).validate(e,t),this.getService(m).validate(e,t)}_validateProperty(e,t,r){if(!e||"string"!=typeof e)throw new n.R("A first argument of PropertiesDefinitionValidator._validateProperty should be a non-empty String, but %v given.",e);if(!t||"string"!=typeof t)throw new n.R("The property name of the model %v should be a non-empty String, but %v given.",e,t);if(!r)throw new n.R("The property %v of the model %v should have a property definition, but %v given.",t,e,r);if("string"!=typeof r){if(!r||"object"!=typeof r||Array.isArray(r))throw new n.R("In case of a full property definition, the property %v of the model %v should be an Object, but %v given.",t,e,r);if(!r.type||!Object.values(s).includes(r.type))throw new n.R('The property %v of the model %v requires the option "type" to have one of data types: %l, but %v given.',t,e,Object.values(s),r.type);if(r.itemType&&!Object.values(s).includes(r.itemType))throw new n.R('The provided option "itemType" of the property %v in the model %v should have one of data types: %l, but %v given.',t,e,Object.values(s),r.itemType);if(r.model&&"string"!=typeof r.model)throw new n.R('The provided option "model" of the property %v in the model %v should be a String, but %v given.',t,e,r.model);if(r.primaryKey&&"boolean"!=typeof r.primaryKey)throw new n.R('The provided option "primaryKey" of the property %v in the model %v should be a Boolean, but %v given.',t,e,r.primaryKey);if(r.columnName&&"string"!=typeof r.columnName)throw new n.R('The provided option "columnName" of the property %v in the model %v should be a String, but %v given.',t,e,r.columnName);if(r.columnType&&"string"!=typeof r.columnType)throw new n.R('The provided option "columnType" of the property %v in the model %v should be a String, but %v given.',t,e,r.columnType);if(r.required&&"boolean"!=typeof r.required)throw new n.R('The provided option "required" of the property %v in the model %v should be a Boolean, but %v given.',t,e,r.required);if(r.required&&void 0!==r.default)throw new n.R('The property %v of the model %v is a required property, so it should not have the option "default" to be provided.',t,e);if(r.primaryKey&&r.required)throw new n.R('The property %v of the model %v is a primary key, so it should not have the option "required" to be provided.',t,e);if(r.primaryKey&&void 0!==r.default)throw new n.R('The property %v of the model %v is a primary key, so it should not have the option "default" to be provided.',t,e);if(r.itemType&&r.type!==s.ARRAY)throw new n.R('The property %v of the model %v has the non-array type, so it should not have the option "itemType" to be provided.',t,e,r.type);if(r.model&&r.type!==s.OBJECT)throw new n.R('The property %v of the model %v has the non-object type, so it should not have the option "model" to be provided.',t,e,r.type)}else if(!Object.values(s).includes(r))throw new n.R("In case of a short property definition, the property %v of the model %v should have one of data types: %l, but %v given.",t,e,Object.values(s),r)}}class b extends i.t{sanitize(e,t){if(!e||"string"!=typeof e)throw new n.R("The first argument of ModelDataSanitizer.sanitize must be a string, but %v given.",e);if(!t||"object"!=typeof t)throw new n.R("The second argument of ModelDataSanitizer.sanitize must be an Object, but %v given.",t);return this.getService(p).excludeObjectKeysByRelationNames(e,t)}}class w extends i.t{validate(e){if(!e||"object"!=typeof e||Array.isArray(e))throw new n.R("The model definition should be an Object, but %v given.",e);if(!e.name||"string"!=typeof e.name)throw new n.R('The model definition requires the option "name" as a non-empty String, but %v given.',e.name);if(e.datasource&&"string"!=typeof e.datasource)throw new n.R('The provided option "datasource" of the model %v should be a String, but %v given.',e.name,e.datasource);if(e.base&&"string"!=typeof e.base)throw new n.R('The provided option "base" of the model %v should be a String, but %v given.',e.name,e.base);if(e.tableName&&"string"!=typeof e.tableName)throw new n.R('The provided option "tableName" of the model %v should be a String, but %v given.',e.name,e.tableName);if(e.properties){if("object"!=typeof e.properties||Array.isArray(e.properties))throw new n.R('The provided option "properties" of the model %v should be an Object, but %v given.',e.name,e.properties);this.getService(g).validate(e.name,e.properties)}if(e.relations){if("object"!=typeof e.relations||Array.isArray(e.relations))throw new n.R('The provided option "relations" of the model %v should be an Object, but %v given.',e.name,e.relations);this.getService(a).validate(e.name,e.relations)}}}class R extends i.t{validate(e){if(!e||"object"!=typeof e)throw new n.R("The datasource definition should be an Object, but %v given.",e);if(!e.name||"string"!=typeof e.name)throw new n.R('The datasource definition requires the option "name" as a non-empty String, but %v given.',e.name);if(!e.adapter||"string"!=typeof e.adapter)throw new n.R('The datasource %v requires the option "adapter" as a non-empty String, but %v given.',e.name,e.adapter)}}},524:(e,t,r)=>{"use strict";r.d(t,{R:()=>i});var o=r(403);class i extends o.P{}},319:(e,t,r)=>{"use strict";r.d(t,{M:()=>i});var o=r(911);class i extends Error{constructor(e,t,r){super((0,o.W)("Condition of {%s: ...} should have %s, %v given.",e,t,r))}}},774:(e,t,r)=>{"use strict";r.d(t,{n:()=>i});var o=r(403);class i extends o.P{}},202:(e,t,r)=>{"use strict";r.d(t,{NF:()=>y,A9:()=>m,tn:()=>f,$Z:()=>s,hH:()=>n,d4:()=>p});var o=r(1),i=r(524);class n extends o.t{slice(e,t=void 0,r=void 0){if(!Array.isArray(e))throw new i.R("A first argument of SliceClauseTool.slice should be an Array, but %v given.",e);if(t&&"number"!=typeof t)throw new i.R('The provided option "skip" should be a Number, but %v given.',t);if(r&&"number"!=typeof r)throw new i.R('The provided option "limit" should be a Number, but %v given.',r);return t=t||0,r=r||e.length,e.slice(t,t+r)}static validateSkipClause(e){if(e&&"number"!=typeof e)throw new i.R('The provided option "skip" should be a Number, but %v given.',e)}static validateLimitClause(e){if(e&&"number"!=typeof e)throw new i.R('The provided option "limit" should be a Number, but %v given.',e)}}var a=r(972);class s extends o.t{sort(e,t){if(!t)return;Array.isArray(t)||(t=[t]);const r=[];t.forEach(((e,t)=>{if("string"!=typeof e)throw new i.R('The provided option "order" should be a String or an Array of String, but %v given.',e);let o=1;const n=e.match(/\s+(A|DE)SC$/i);n&&(e=e.replace(/\s+(A|DE)SC/i,""),"de"===n[1].toLowerCase()&&(o=-1)),r[t]={key:e,reverse:o}})),e.sort(l.bind(r))}static validateOrderClause(e){e&&(Array.isArray(e)?e:[e]).forEach((e=>{if(!e||"string"!=typeof e)throw new i.R('The provided option "order" should be a non-empty String or an Array of String, but %v given.',e)}))}static normalizeOrderClause(e){if(e)return(e=Array.isArray(e)?e:[e]).forEach((e=>{if(!e||"string"!=typeof e)throw new i.R('The provided option "order" should be a non-empty String or an Array of String, but %v given.',e)})),e}}function l(e,t){let r,o;for(let i=0,n=this.length;i<n;i++){const n=(0,a.M)(e,this[i].key),s=(0,a.M)(t,this[i].key);if(o=void 0===s&&void 0!==n,r=void 0===n&&void 0!==s,o||n>s)return this[i].reverse;if(r||n<s)return-1*this[i].reverse}return 0}var c=r(318),h=r(319);class f extends o.t{compare(e,t){if(null==e||null==t)return e==t?0:NaN;if("number"==typeof e)return"number"==typeof t||"string"==typeof t||"boolean"==typeof t?e===t?0:e-Number(t):NaN;if("string"==typeof e){if(/^\d+$/.test(e))return this.compare(Number(e),t);try{if(e>t)return 1;if(e<t)return-1;if(e==t)return 0}catch(e){}return NaN}return"boolean"==typeof e?Number(e)-Number(t):e===t?0:NaN}testAll(e,t){if(!e||"object"!=typeof e||Array.isArray(e))throw new i.R("A first argument of OperatorUtils.testAll should be an Object, but %v given.",e);const r=this.testEqNeq(e,t);if(void 0!==r)return r;const o=this.testGtLt(e,t);if(void 0!==o)return o;const n=this.testInq(e,t);if(void 0!==n)return n;const a=this.testNin(e,t);if(void 0!==a)return a;const s=this.testBetween(e,t);if(void 0!==s)return s;const l=this.testExists(e,t);if(void 0!==l)return l;const c=this.testLike(e,t);if(void 0!==c)return c;const h=this.testNlike(e,t);if(void 0!==h)return h;const f=this.testIlike(e,t);if(void 0!==f)return f;const p=this.testNilike(e,t);if(void 0!==p)return p;const d=this.testRegexp(e,t);return void 0!==d?d:void 0}testEqNeq(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testEqNeq should be an Object, but %v given.",e);return"eq"in e?0===this.compare(e.eq,t):"neq"in e?0!==this.compare(e.neq,t):void 0}testGtLt(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testGtLt should be an Object, but %v given.",e);return"gt"in e?this.compare(t,e.gt)>0:"gte"in e?this.compare(t,e.gte)>=0:"lt"in e?this.compare(t,e.lt)<0:"lte"in e?this.compare(t,e.lte)<=0:void 0}testInq(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testInq should be an Object, but %v given.",e);if("inq"in e&&void 0!==e.inq){if(!e.inq||!Array.isArray(e.inq))throw new h.M("inq","an Array of possible values",e.inq);for(let r=0;r<e.inq.length;r++)if(e.inq[r]==t)return!0;return!1}}testNin(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testNin should be an Object, but %v given.",e);if("nin"in e&&void 0!==e.nin){if(!e.nin||!Array.isArray(e.nin))throw new h.M("nin","an Array of possible values",e.nin);for(let r=0;r<e.nin.length;r++)if(e.nin[r]==t)return!1;return!0}}testBetween(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testBetween should be an Object, but %v given.",e);if("between"in e&&void 0!==e.between){if(!Array.isArray(e.between)||2!==e.between.length)throw new h.M("between","an Array of 2 elements",e.between);return this.testGtLt({gte:e.between[0]},t)&&this.testGtLt({lte:e.between[1]},t)}}testExists(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testExists should be an Object, but %v given.",e);if("exists"in e&&void 0!==e.exists){if("boolean"!=typeof e.exists)throw new h.M("exists","a Boolean",e.exists);return e.exists?void 0!==t:void 0===t}}testLike(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testLike should be an Object, but %v given.",e);if("like"in e&&void 0!==e.like){if("string"!=typeof e.like&&!(e.like instanceof RegExp))throw new h.M("like","a String",e.like);return(0,c.H)(e.like).test(t)}}testNlike(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testNlike should be an Object, but %v given.",e);if("nlike"in e&&void 0!==e.nlike){if("string"!=typeof e.nlike&&!(e.nlike instanceof RegExp))throw new h.M("nlike","a String",e.nlike);return!(0,c.H)(e.nlike).test(t)}}testIlike(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testIlike should be an Object, but %v given.",e);if("ilike"in e&&void 0!==e.ilike){if("string"!=typeof e.ilike&&!(e.ilike instanceof RegExp))throw new h.M("ilike","a String",e.ilike);return(0,c.H)(e.ilike,"i").test(t)}}testNilike(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testNilike should be an Object, but %v given.",e);if("nilike"in e&&void 0!==e.nilike){if("string"!=typeof e.nilike&&!(e.nilike instanceof RegExp))throw new h.M("nilike","a String",e.nilike);return!(0,c.H)(e.nilike,"i").test(t)}}testRegexp(e,t){if(!e||"object"!=typeof e)throw new i.R("A first argument of OperatorUtils.testRegexp should be an Object, but %v given.",e);if("regexp"in e&&void 0!==e.regexp){if("string"!=typeof e.regexp&&!(e.regexp instanceof RegExp))throw new h.M("regexp","a String",e.regexp);const r=e.flags||void 0;if(r&&"string"!=typeof r)throw new i.R("RegExp flags must be a String, but %v given.",e.flags);if(!t||"string"!=typeof t)return!1;const o=(0,c.H)(e.regexp,r);return!!t.match(o)}}}class p extends o.t{filter(e,t=void 0){if(!Array.isArray(e))throw new i.R("A first argument of WhereUtils.filter should be an Array of Objects, but %v given.",e);return t?e.filter(this._createFilter(t)):e}_createFilter(e){if("function"==typeof e)return e;if("object"!=typeof e)throw new i.R('The provided option "where" should be an Object, but %v given.',e);const t=Object.keys(e);return r=>{if("object"!=typeof r)throw new i.R("A first argument of WhereUtils.filter should be an Array of Objects, but %v given.",r);return t.every((t=>{if("and"===t&&t in e){const o=e[t];if(Array.isArray(o))return o.every((e=>this._createFilter(e)(r)))}else if("or"===t&&t in e){const o=e[t];if(Array.isArray(o))return o.some((e=>this._createFilter(e)(r)))}const o=(0,a.M)(r,t),i=e[t];return Array.isArray(o)?"object"==typeof i&&null!==i&&"neq"in i&&void 0!==i.neq?0===o.length||o.every(((e,t)=>{const r={};return r[t]=i,this._createFilter(r)({...o})})):o.some(((e,t)=>{const r={};return r[t]=i,this._createFilter(r)({...o})})):!!this._test(i,o)||void 0}))}}_test(e,t){if(null==e)return null==t;if(e instanceof RegExp)return"string"==typeof t&&!!t.match(e);if("object"==typeof e){const r=this.getService(f).testAll(e,t);if(void 0!==r)return r}return e==t}static validateWhereClause(e){if(e&&("object"!=typeof e||Array.isArray(e)))throw new i.R('The provided option "where" should be an Object, but %v given.',e)}}var d=r(782),u=r(606);class y extends o.t{filter(e,t,r){const o=Array.isArray(e);if((e=o?e:[e]).forEach((e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw new i.R("A first argument of FieldClauseTool.filter should be an Object or an Array of Object, but %v given.",e)})),!r)return e;const n=Array.isArray(r)?r.slice():[r];n.forEach((e=>{if(!e||"string"!=typeof e)throw new i.R('The provided option "fields" should be a String or an Array of String, but %v given.',e)}));const a=this.getService(u.r0).getPrimaryKeyAsPropertyName(t);return-1===n.indexOf(a)&&n.push(a),e=e.map((e=>(0,d.T)(e,n))),o?e:e[0]}static validateFieldsClause(e){e&&(Array.isArray(e)?e:[e]).forEach((e=>{if(!e||"string"!=typeof e)throw new i.R('The provided option "fields" should be a non-empty String or an Array of String, but %v given.',e)}))}static normalizeFieldsClause(e){if(e)return(e=Array.isArray(e)?e:[e]).forEach((e=>{if(!e||"string"!=typeof e)throw new i.R('The provided option "fields" should be a non-empty String or an Array of String, but %v given.',e)})),e}}var v=r(40);class m extends o.t{async includeTo(e,t,r){r=m.normalizeIncludeClause(r);const o=[];r.forEach((r=>{const n=this.getService(u.r0).getRelationDefinitionByName(t,r.relation);switch(n.type){case u.uT.BELONGS_TO:n.polymorphic?o.push(this.getService(v.mr).includePolymorphicTo(e,t,r.relation,n.foreignKey,n.discriminator,r.scope)):o.push(this.getService(v.mr).includeTo(e,t,n.model,r.relation,n.foreignKey,r.scope));break;case u.uT.HAS_ONE:n.polymorphic&&"string"==typeof n.polymorphic?o.push(this.getService(v.VY).includePolymorphicByRelationName(e,t,n.model,r.relation,n.polymorphic,r.scope)):n.polymorphic?o.push(this.getService(v.VY).includePolymorphicTo(e,t,n.model,r.relation,n.foreignKey,n.discriminator,r.scope)):o.push(this.getService(v.VY).includeTo(e,t,n.model,r.relation,n.foreignKey,r.scope));break;case u.uT.HAS_MANY:n.polymorphic&&"string"==typeof n.polymorphic?o.push(this.getService(v.z8).includePolymorphicByRelationName(e,t,n.model,r.relation,n.polymorphic,r.scope)):n.polymorphic?o.push(this.getService(v.z8).includePolymorphicTo(e,t,n.model,r.relation,n.foreignKey,n.discriminator,r.scope)):o.push(this.getService(v.z8).includeTo(e,t,n.model,r.relation,n.foreignKey,r.scope));break;case u.uT.REFERENCES_MANY:o.push(this.getService(v.V0).includeTo(e,t,n.model,r.relation,n.foreignKey,r.scope));break;default:throw new i.R("The relation type %v does not have an inclusion resolver.",n.type)}})),await Promise.all(o)}static validateIncludeClause(e){if(e)if("string"==typeof e);else if(Array.isArray(e)){const t=[];e.flat().forEach((e=>{this.validateIncludeClause(e),"string"==typeof e?t.push(e):"object"==typeof e&&Object.keys(e).forEach((r=>{Object.prototype.hasOwnProperty.call(e,r)&&t.push(r)}))}));const r=t.filter(((e,r)=>t.indexOf(e)!==r));if(r.length)throw new i.R('The provided option "include" has duplicates of %v.',r[0])}else{if("object"!=typeof e)throw new i.R('The provided option "include" should have a value of following types: String, Object or Array, but %v given.',e);if("relation"in e){if(!e.relation||"string"!=typeof e.relation)throw new i.R('The provided option "relation" should be a non-empty String, but %v given.',e.relation);"scope"in e&&e&&this.validateScopeClause(e.scope)}else Object.keys(e).forEach((t=>{Object.prototype.hasOwnProperty.call(e,t)&&this.validateIncludeClause(e[t])}))}}static validateScopeClause(e){if(e){if("object"!=typeof e||Array.isArray(e))throw new i.R('The provided option "scope" should be an Object, but %v given.',e);"where"in e&&e.where&&p.validateWhereClause(e.where),"order"in e&&e.order&&s.validateOrderClause(e.order),"skip"in e&&e.skip&&n.validateSkipClause(e.skip),"limit"in e&&e.limit&&n.validateLimitClause(e.limit),"fields"in e&&e.fields&&y.validateFieldsClause(e.fields),"include"in e&&e.include&&m.validateIncludeClause(e.include)}}static normalizeIncludeClause(e){let t=[];if(!e)return t;if("string"==typeof e)t.push({relation:e});else if(Array.isArray(e)){e.flat().forEach((e=>{e=Array.isArray(e)?e.flat().map((e=>this.normalizeIncludeClause(e))).flat():this.normalizeIncludeClause(e),t=[...t,...e]}));const r=t.map((e=>e.relation)),o=r.filter(((e,t)=>r.indexOf(e)!==t));if(o.length)throw new i.R('The provided option "include" has duplicates of %v.',o[0])}else{if("object"!=typeof e)throw new i.R('The provided option "include" should have a value of following types: String, Object or Array, but %v given.',e);if("relation"in e){if(!e.relation||"string"!=typeof e.relation)throw new i.R('The provided option "relation" should be a non-empty String, but %v given.',e.relation);const r={relation:e.relation},o=this.normalizeScopeClause(e.scope);o&&(r.scope=o),t.push(r)}else Object.keys(e).forEach((r=>{if(!Object.prototype.hasOwnProperty.call(e,r))return;const o={relation:r},i=this.normalizeIncludeClause(e[r]);i.length&&(o.scope={include:i}),t.push(o)}))}return t}static normalizeScopeClause(e){if(!e)return;if("object"!=typeof e||Array.isArray(e))throw new i.R('The provided option "scope" should be an Object, but %v given.',e);const t={};return"where"in e&&e.where&&(p.validateWhereClause(e.where),t.where=e.where),"order"in e&&e.order&&(s.validateOrderClause(e.order),t.order=e.order),"skip"in e&&e.skip&&(n.validateSkipClause(e.skip),t.skip=e.skip),"limit"in e&&e.limit&&(n.validateLimitClause(e.limit),t.limit=e.limit),"fields"in e&&e.fields&&(y.validateFieldsClause(e.fields),t.fields=e.fields),"include"in e&&e.include&&(t.include=this.normalizeIncludeClause(e.include)),Object.keys(t).length?t:void 0}}},40:(e,t,r)=>{"use strict";r.d(t,{mr:()=>f,z8:()=>c,VY:()=>l,V0:()=>p});var o=r(1),i=r(390),n=r(606),a=r(524),s=r(452);class l extends o.t{async includeTo(e,t,r,o,l,c=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of HasOneResolver.includeTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of HasOneResolver.includeTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of HasOneResolver.includeTo requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of HasOneResolver.includeTo requires a non-empty String, but %v given.',o);if(!l||"string"!=typeof l)throw new a.R('The parameter "foreignKey" of HasOneResolver.includeTo requires a non-empty String, but %v given.',l);if(c&&("object"!=typeof c||Array.isArray(c)))throw new a.R('The provided parameter "scope" of HasOneResolver.includeTo should be an Object, but %v given.',c);const h=this.getService(n.r0).getPrimaryKeyAsPropertyName(t),f=[];e.forEach((e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw new a.R('The parameter "entities" of HasOneResolver.includeTo requires an Array of Object, but %v given.',e);const t=e[h];f.includes(t)||f.push(t)}));const p=[],d=this.getService(s.i).getRepository(r);c=c?(0,i.X)(c):{};const u=new Map;f.forEach((e=>{const t=(0,i.X)(c);t.where={and:[{[l]:e},...c.where?[c.where]:[]]},t.limit=1,p.push(d.find(t).then((t=>{t.length&&u.set(e,t[0])})))})),await Promise.all(p),Array.from(u.keys()).forEach((t=>{e.filter((e=>e[h]===t)).forEach((e=>e[o]=u.get(t)))}))}async includePolymorphicTo(e,t,r,o,l,c,h=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of HasOneResolver.includePolymorphicTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of HasOneResolver.includePolymorphicTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of HasOneResolver.includePolymorphicTo requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of HasOneResolver.includePolymorphicTo requires a non-empty String, but %v given.',o);if(!l||"string"!=typeof l)throw new a.R('The parameter "foreignKey" of HasOneResolver.includePolymorphicTo requires a non-empty String, but %v given.',l);if(!c||"string"!=typeof c)throw new a.R('The parameter "discriminator" of HasOneResolver.includePolymorphicTo requires a non-empty String, but %v given.',c);if(h&&("object"!=typeof h||Array.isArray(h)))throw new a.R('The provided parameter "scope" of HasOneResolver.includePolymorphicTo should be an Object, but %v given.',h);const f=this.getService(n.r0).getPrimaryKeyAsPropertyName(t),p=[];e.forEach((e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw new a.R('The parameter "entities" of HasOneResolver.includePolymorphicTo requires an Array of Object, but %v given.',e);const t=e[f];p.includes(t)||p.push(t)}));const d=[],u=this.getService(s.i).getRepository(r);h=h?(0,i.X)(h):{};const y=new Map;p.forEach((e=>{const r=(0,i.X)(h);r.where={and:[{[l]:e,[c]:t},...h.where?[h.where]:[]]},r.limit=1,d.push(u.find(r).then((t=>{t.length&&y.set(e,t[0])})))})),await Promise.all(d),Array.from(y.keys()).forEach((t=>{e.filter((e=>e[f]===t)).forEach((e=>e[o]=y.get(t)))}))}async includePolymorphicByRelationName(e,t,r,o,i,s=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of HasOneResolver.includePolymorphicByRelationName requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of HasOneResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of HasOneResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of HasOneResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',o);if(!i||"string"!=typeof i)throw new a.R('The parameter "targetRelationName" of HasOneResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',i);if(s&&("object"!=typeof s||Array.isArray(s)))throw new a.R('The provided parameter "scope" of HasOneResolver.includePolymorphicByRelationName should be an Object, but %v given.',s);const l=this.getService(n.r0).getRelationDefinitionByName(r,i);if(l.type!==n.uT.BELONGS_TO)throw new a.R('The relation %v of the model %v is a polymorphic "hasOne" relation, so it requires the target relation %v to be a polymorphic "belongsTo", but %v type given.',o,t,i,l.type);if(!l.polymorphic)throw new a.R('The relation %v of the model %v is a polymorphic "hasOne" relation, so it requires the target relation %v to be a polymorphic too.',o,t,i);const c=l.foreignKey||`${i}Id`,h=l.discriminator||`${i}Type`;return this.includePolymorphicTo(e,t,r,o,c,h,s)}}class c extends o.t{async includeTo(e,t,r,o,l,c=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of HasManyResolver.includeTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of HasManyResolver.includeTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of HasManyResolver.includeTo requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of HasManyResolver.includeTo requires a non-empty String, but %v given.',o);if(!l||"string"!=typeof l)throw new a.R('The parameter "foreignKey" of HasManyResolver.includeTo requires a non-empty String, but %v given.',l);if(c&&("object"!=typeof c||Array.isArray(c)))throw new a.R('The provided parameter "scope" of HasManyResolver.includeTo should be an Object, but %v given.',c);const h=this.getService(n.r0).getPrimaryKeyAsPropertyName(t),f=[];e.forEach((e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw new a.R('The parameter "entities" of HasManyResolver.includeTo requires an Array of Object, but %v given.',e);const t=e[h];f.includes(t)||f.push(t)}));const p=[],d=this.getService(s.i).getRepository(r);c=c?(0,i.X)(c):{};const u=new Map;f.forEach((e=>{const t=(0,i.X)(c);t.where={and:[{[l]:e},...c.where?[c.where]:[]]},p.push(d.find(t).then((t=>{if(t.length){let r=u.get(e)??[];r=[...r,...t],u.set(e,r)}})))})),await Promise.all(p),e.forEach((e=>{const t=e[h];e[o]=u.get(t)??[]}))}async includePolymorphicTo(e,t,r,o,l,c,h=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of HasManyResolver.includePolymorphicTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of HasManyResolver.includePolymorphicTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of HasManyResolver.includePolymorphicTo requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of HasManyResolver.includePolymorphicTo requires a non-empty String, but %v given.',o);if(!l||"string"!=typeof l)throw new a.R('The parameter "foreignKey" of HasManyResolver.includePolymorphicTo requires a non-empty String, but %v given.',l);if(!c||"string"!=typeof c)throw new a.R('The parameter "discriminator" of HasManyResolver.includePolymorphicTo requires a non-empty String, but %v given.',c);if(h&&("object"!=typeof h||Array.isArray(h)))throw new a.R('The provided parameter "scope" of HasManyResolver.includePolymorphicTo should be an Object, but %v given.',h);const f=this.getService(n.r0).getPrimaryKeyAsPropertyName(t),p=[];e.forEach((e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw new a.R('The parameter "entities" of HasManyResolver.includePolymorphicTo requires an Array of Object, but %v given.',e);const t=e[f];p.includes(t)||p.push(t)}));const d=[],u=this.getService(s.i).getRepository(r);h=h?(0,i.X)(h):{};const y=new Map;p.forEach((e=>{const r=(0,i.X)(h);r.where={and:[{[l]:e,[c]:t},...h.where?[h.where]:[]]},d.push(u.find(r).then((t=>{if(t.length){let r=y.get(e)??[];r=[...r,...t],y.set(e,r)}})))})),await Promise.all(d),e.forEach((e=>{const t=e[f];e[o]=y.get(t)??[]}))}async includePolymorphicByRelationName(e,t,r,o,i,s=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of HasManyResolver.includePolymorphicByRelationName requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of HasManyResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of HasManyResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of HasManyResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',o);if(!i||"string"!=typeof i)throw new a.R('The parameter "targetRelationName" of HasManyResolver.includePolymorphicByRelationName requires a non-empty String, but %v given.',i);if(s&&("object"!=typeof s||Array.isArray(s)))throw new a.R('The provided parameter "scope" of HasManyResolver.includePolymorphicByRelationName should be an Object, but %v given.',s);const l=this.getService(n.r0).getRelationDefinitionByName(r,i);if(l.type!==n.uT.BELONGS_TO)throw new a.R('The relation %v of the model %v is a polymorphic "hasMany" relation, so it requires the target relation %v to be a polymorphic "belongsTo", but %v type given.',o,t,i,l.type);if(!l.polymorphic)throw new a.R('The relation %v of the model %v is a polymorphic "hasMany" relation, so it requires the target relation %v to be a polymorphic too.',o,t,i);const c=l.foreignKey||`${i}Id`,h=l.discriminator||`${i}Type`;return this.includePolymorphicTo(e,t,r,o,c,h,s)}}var h=r(641);class f extends o.t{async includeTo(e,t,r,o,l=void 0,c=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of BelongsToResolver.includeTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of BelongsToResolver.includeTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of BelongsToResolver.includeTo requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of BelongsToResolver.includeTo requires a non-empty String, but %v given.',o);if(l&&"string"!=typeof l)throw new a.R('The provided parameter "foreignKey" of BelongsToResolver.includeTo should be a String, but %v given.',l);if(c&&("object"!=typeof c||Array.isArray(c)))throw new a.R('The provided parameter "scope" of BelongsToResolver.includeTo should be an Object, but %v given.',c);null==l&&(l=`${o}Id`);const h=e.reduce(((e,t)=>{if(!t||"object"!=typeof t||Array.isArray(t))throw new a.R('The parameter "entities" of BelongsToResolver.includeTo requires an Array of Object, but %v given.',t);const r=t[l];return null!=r?[...e,r]:e}),[]),f=this.getService(s.i).getRepository(r),p=this.getService(n.r0).getPrimaryKeyAsPropertyName(r);c=c?(0,i.X)(c):{};const d=(0,i.X)(c);d.where={and:[{[p]:{inq:h}},...c.where?[c.where]:[]]};const u=await f.find(d);e.forEach((e=>{const t=u.find((t=>t[p]===e[l]));t&&(e[o]=t)}))}async includePolymorphicTo(e,t,r,o=void 0,l=void 0,c=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of BelongsToResolver.includePolymorphicTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of BelongsToResolver.includePolymorphicTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "relationName" of BelongsToResolver.includePolymorphicTo requires a non-empty String, but %v given.',r);if(o&&"string"!=typeof o)throw new a.R('The provided parameter "foreignKey" of BelongsToResolver.includePolymorphicTo should be a String, but %v given.',o);if(l&&"string"!=typeof l)throw new a.R('The provided parameter "discriminator" of BelongsToResolver.includePolymorphicTo should be a String, but %v given.',l);if(c&&("object"!=typeof c||Array.isArray(c)))throw new a.R('The provided parameter "scope" of BelongsToResolver.includePolymorphicTo should be an Object, but %v given.',c);if(null==o){const e=(0,h.C)(r);o=`${e}Id`}if(null==l){const e=(0,h.C)(r);l=`${e}Type`}const f={};e.forEach((e=>{if(!e||"object"!=typeof e||Array.isArray(e))throw new a.R('The parameter "entities" of BelongsToResolver.includePolymorphicTo requires an Array of Object, but %v given.',e);const t=e[o],r=e[l];null!=t&&null!=r&&(null==f[r]&&(f[r]=[]),f[r].includes(t)||f[r].push(t))}));const p=[],d=Object.keys(f);c=c?(0,i.X)(c):{};const u={};d.forEach((e=>{let t;try{t=this.getService(s.i).getRepository(e)}catch(t){if(!(t instanceof a.R))throw t;if(t.message===`The model "${e}" is not defined.`||t.message===`The model "${e}" does not have a specified datasource.`)return}const r=this.getService(n.r0).getPrimaryKeyAsPropertyName(e),o=(0,i.X)(c),l=f[e];o.where={and:[{[r]:{inq:l}},...c.where?[c.where]:[]]};const h=t.find(o).then((t=>{u[e]=[...u[e]??[],...t]}));p.push(h)})),await Promise.all(p),e.forEach((e=>{const t=e[o],i=e[l];if(null==t||null==i||null==u[i])return;const a=u[i]??[],s=this.getService(n.r0).getPrimaryKeyAsPropertyName(i),c=a.find((e=>e[s]===t));c&&(e[r]=c)}))}}class p extends o.t{async includeTo(e,t,r,o,l=void 0,c=void 0){if(!e||!Array.isArray(e))throw new a.R('The parameter "entities" of ReferencesManyResolver.includeTo requires an Array of Object, but %v given.',e);if(!t||"string"!=typeof t)throw new a.R('The parameter "sourceName" of ReferencesManyResolver.includeTo requires a non-empty String, but %v given.',t);if(!r||"string"!=typeof r)throw new a.R('The parameter "targetName" of ReferencesManyResolver.includeTo requires a non-empty String, but %v given.',r);if(!o||"string"!=typeof o)throw new a.R('The parameter "relationName" of ReferencesManyResolver.includeTo requires a non-empty String, but %v given.',o);if(l&&"string"!=typeof l)throw new a.R('The provided parameter "foreignKey" of ReferencesManyResolver.includeTo should be a String, but %v given.',l);if(c&&("object"!=typeof c||Array.isArray(c)))throw new a.R('The provided parameter "scope" of ReferencesManyResolver.includeTo should be an Object, but %v given.',c);if(null==l){const e=(0,h.C)(o);l=`${e}Ids`}const f=e.reduce(((e,t)=>{if(!t||"object"!=typeof t||Array.isArray(t))throw new a.R('The parameter "entities" of ReferencesManyResolver.includeTo requires an Array of Object, but %v given.',t);const r=t[l];return Array.isArray(r)&&r.forEach((t=>{null==t||e.includes(t)||e.push(t)})),e}),[]),p=this.getService(s.i).getRepository(r),d=this.getService(n.r0).getPrimaryKeyAsPropertyName(r);c=c?(0,i.X)(c):{};const u=(0,i.X)(c);u.where={and:[{[d]:{inq:f}},...c.where?[c.where]:[]]};const y=await p.find(u);e.forEach((e=>{const t=e[l];e[o]=[],Array.isArray(t)&&y.forEach((r=>{const i=r[d];t.includes(i)&&e[o].push(r)}))}))}}},452:(e,t,r)=>{"use strict";r.d(t,{_:()=>s,i:()=>l});var o=r(1),i=r(949),n=r(524),a=r(606);class s extends o.t{_modelName;get modelName(){return this._modelName}_datasourceName;get datasourceName(){return this._datasourceName}constructor(e,t){super(e),this._modelName=t;const r=this.getService(a.D5).getModel(t).datasource;if(!r)throw new n.R("The model %v does not have a specified datasource.",t);this._datasourceName=r}async getAdapter(){return this.getService(i.gO).getAdapter(this.datasourceName)}async create(e,t=void 0){return(await this.getAdapter()).create(this.modelName,e,t)}async replaceById(e,t,r=void 0){return(await this.getAdapter()).replaceById(this.modelName,e,t,r)}async replaceOrCreate(e,t=void 0){const r=e[this.getService(a.r0).getPrimaryKeyAsPropertyName(this.modelName)];return null==r?this.create(e,t):this.replaceById(r,e,t)}async patchById(e,t,r=void 0){return(await this.getAdapter()).patchById(this.modelName,e,t,r)}async find(e=void 0){return(await this.getAdapter()).find(this.modelName,e)}async findOne(e=void 0){const t=await this.getAdapter();(e=e??{}).limit=1;const r=await t.find(this.modelName,e);return r.length?r[0]:void 0}async findById(e,t=void 0){return(await this.getAdapter()).findById(this.modelName,e,t)}async delete(e=void 0){return(await this.getAdapter()).delete(this.modelName,e)}async deleteById(e){return(await this.getAdapter()).deleteById(this.modelName,e)}async exists(e){return(await this.getAdapter()).exists(this.modelName,e)}async count(e=void 0){return(await this.getAdapter()).count(this.modelName,e)}}class l extends o.t{_repositories={};_repositoryCtor=s;setRepositoryCtor(e){if(!(e&&"function"==typeof e&&e.prototype instanceof s))throw new n.R("The first argument of RepositoryRegistry.setRepositoryCtor must inherit from Repository class, but %v given.",e);this._repositoryCtor=e}getRepository(e){let t=this._repositories[e];return t||(t=new this._repositoryCtor(this.container,e),this._repositories[e]=t,t)}}},286:(e,t,r)=>{"use strict";function o(e){return e&&"string"==typeof e?e.charAt(0).toUpperCase()+e.slice(1):e}r.d(t,{k:()=>o})},390:(e,t,r)=>{"use strict";function o(e){if(!e)return e;let t;if([Number,String,Boolean].forEach((r=>{e instanceof r&&(t=r(e))})),void 0===t)if(Array.isArray(e))t=[],e.forEach(((e,r)=>{t[r]=o(e)}));else if("object"==typeof e)if("nodeType"in e&&e.nodeType&&"cloneNode"in e&&"function"==typeof e.cloneNode)t=e.cloneNode(!0);else if("prototype"in e&&e.prototype)t=e;else if(e instanceof Date)t=new Date(e);else if(e.constructor&&"Object"===e.constructor.name){t={};for(const r in e)t[r]=o(e[r])}else t=e;else t=e;return t}r.d(t,{X:()=>o})},918:(e,t,r)=>{"use strict";r.d(t,{H:()=>i});var o=r(524);function i(e,t){if("object"!=typeof e||!e||Array.isArray(e))throw new o.R("Cannot exclude keys from a non-Object value, %v given.",e);const r={...e};return(t=Array.isArray(t)?t:[t]).forEach((e=>delete r[e])),r}},110:(e,t,r)=>{"use strict";function o(e){return null===e?"Null":void 0===e?"Undefined":e.constructor&&e.constructor.name||void 0}r.d(t,{F:()=>o})},972:(e,t,r)=>{"use strict";function o(e,t,r=void 0){if(!e||"object"!=typeof e)return r;if(!t||"string"!=typeof t)return r;const o=t.split(".");let i=e;for(const e of o){if("object"!=typeof i||null===i||!(e in i)){i=r;break}i=i[e]}return i}r.d(t,{M:()=>o})},697:(e,t,r)=>{"use strict";function o(e){return Boolean("object"==typeof e&&e&&!Array.isArray(e)&&(!e.constructor||e.constructor&&"Object"===e.constructor.name))}r.d(t,{S:()=>o})},782:(e,t,r)=>{"use strict";r.d(t,{T:()=>i});var o=r(524);function i(e,t){if(!e||"object"!=typeof e||Array.isArray(e))throw new o.R("A first argument of selectObjectKeys should be an Object, but %v given.",e);if(!Array.isArray(t))throw new o.R("A second argument of selectObjectKeys should be an Array of String, but %v given.",t);t.forEach((e=>{if("string"!=typeof e)throw new o.R("A second argument of selectObjectKeys should be an Array of String, but %v given.",e)}));const r={};return Object.keys(e).forEach((o=>{t.includes(o)&&(r[o]=e[o])})),r}},641:(e,t,r)=>{"use strict";function o(e){if(!e||"string"!=typeof e)return e;const t={ves:"fe",ies:"y",i:"us",zes:"ze",ses:"s",es:"e",s:""};return e.replace(new RegExp(`(${Object.keys(t).join("|")})$`),(e=>t[e]))}r.d(t,{C:()=>o})},318:(e,t,r)=>{"use strict";function o(e,t=void 0){if(e instanceof RegExp)return new RegExp(e,t);let r="";for(let t=0,o=e.length;t<o;t++){const o=e.charAt(t);r+="%"===o?".*":o}return new RegExp(r,t)}r.d(t,{H:()=>o})}},o={};function i(e){var t=o[e];if(void 0!==t)return t.exports;var n=o[e]={exports:{}};return r[e](n,n.exports,i),n.exports}i.m=r,i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce(((t,r)=>(i.f[r](e,t),t)),[])),i.u=e=>e+".main.js",i.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e={},t="@e22m4u/node-repository:",i.l=(r,o,n,a)=>{if(e[r])e[r].push(o);else{var s,l;if(void 0!==n)for(var c=document.getElementsByTagName("script"),h=0;h<c.length;h++){var f=c[h];if(f.getAttribute("src")==r||f.getAttribute("data-webpack")==t+n){s=f;break}}s||(l=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.setAttribute("data-webpack",t+n),s.src=r),e[r]=[o];var p=(t,o)=>{s.onerror=s.onload=null,clearTimeout(d);var i=e[r];if(delete e[r],s.parentNode&&s.parentNode.removeChild(s),i&&i.forEach((e=>e(o))),t)return t(o)},d=setTimeout(p.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=p.bind(null,s.onerror),s.onload=p.bind(null,s.onload),l&&document.head.appendChild(s)}},i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;i.g.importScripts&&(e=i.g.location+"");var t=i.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var o=r.length-1;o>-1&&!e;)e=r[o--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),i.p=e})(),(()=>{var e={179:0};i.f.j=(t,r)=>{var o=i.o(e,t)?e[t]:void 0;if(0!==o)if(o)r.push(o[2]);else{var n=new Promise(((r,i)=>o=e[t]=[r,i]));r.push(o[2]=n);var a=i.p+i.u(t),s=new Error;i.l(a,(r=>{if(i.o(e,t)&&(0!==(o=e[t])&&(e[t]=void 0),o)){var n=r&&("load"===r.type?"missing":r.type),a=r&&r.target&&r.target.src;s.message="Loading chunk "+t+" failed.\n("+n+": "+a+")",s.name="ChunkLoadError",s.type=n,s.request=a,o[1](s)}}),"chunk-"+t,t)}};var t=(t,r)=>{var o,n,[a,s,l]=r,c=0;if(a.some((t=>0!==e[t]))){for(o in s)i.o(s,o)&&(i.m[o]=s[o]);l&&l(i)}for(t&&t(r);c<a.length;c++)n=a[c],i.o(e,n)&&e[n]&&e[n][0](),e[n]=0},r=self.webpackChunk_e22m4u_node_repository=self.webpackChunk_e22m4u_node_repository||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var n={};(()=>{"use strict";i.r(n),i.d(n,{Adapter:()=>w.L1,AdapterLoader:()=>w.iq,AdapterRegistry:()=>w.gO,BelongsToResolver:()=>R.mr,DEFAULT_PRIMARY_KEY_PROPERTY_NAME:()=>r.Dp,DataType:()=>r.g,DatasourceDefinitionValidator:()=>r.Jo,DefaultValuesDefinitionValidator:()=>r.VN,DefinitionRegistry:()=>r.D5,FieldsClauseTool:()=>b.NF,HasManyResolver:()=>R.z8,HasOneResolver:()=>R.VY,IncludeClauseTool:()=>b.A9,InvalidArgumentError:()=>m.R,InvalidOperatorValueError:()=>g.M,ModelDataSanitizer:()=>r.Qv,ModelDataValidator:()=>r.o7,ModelDefinitionUtils:()=>r.r0,ModelDefinitionValidator:()=>r.De,NotImplementedError:()=>v.n,OperatorClauseTool:()=>b.tn,OrderClauseTool:()=>b.$Z,PrimaryKeysDefinitionValidator:()=>r.nc,PropertiesDefinitionValidator:()=>r.wK,ReferencesManyResolver:()=>R.V0,RelationType:()=>r.uT,RelationsDefinitionValidator:()=>r.Qn,Repository:()=>t._,RepositoryRegistry:()=>t.i,Schema:()=>o,SliceClauseTool:()=>b.hH,WhereClauseTool:()=>b.d4,capitalize:()=>s.k,cloneDeep:()=>l.X,excludeObjectKeys:()=>y.H,getCtorName:()=>h.F,getValueByPath:()=>d.M,isCtor:()=>a,isPureObject:()=>f.S,selectObjectKeys:()=>u.T,singularize:()=>c.C,stringToRegexp:()=>p.H});var e=i(1),t=i(452),r=i(606);class o extends e.t{defineDatasource(e){return this.getService(r.D5).addDatasource(e),this}defineModel(e){return this.getService(r.D5).addModel(e),this}getRepository(e){return this.getService(t.i).getRepository(e)}}function a(e){return!!e&&"function"==typeof e&&"prototype"in e}var s=i(286),l=i(390),c=i(641),h=i(110),f=i(697),p=i(318),d=i(972),u=i(782),y=i(918),v=i(774),m=i(524),g=i(319),b=i(202),w=i(949),R=i(40)})();var a=exports;for(var s in n)a[s]=n[s];n.__esModule&&Object.defineProperty(a,"__esModule",{value:!0})})();