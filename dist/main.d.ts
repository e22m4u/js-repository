// Generated by dts-bundle-generator v8.0.1

import { Constructor, Service, ServiceContainer } from '@e22m4u/service';
import { Errorf } from '@e22m4u/util-format';

/**
 * Free-form object with open properties.
 */
export declare type AnyObject = {
	[property: string]: unknown;
};
/**
 * Makes specific field as optional.
 */
export declare type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
/**
 * Model data.
 */
export declare type ModelData = {
	[property: string]: unknown;
};
/**
 * Model id.
 */
export declare type ModelId = unknown;
/**
 * Flatten.
 */
export type Identity<T> = T;
export declare type Flatten<T> = Identity<{
	[k in keyof T]: T[k];
}>;
/**
 * Is ctor.
 *
 * @param {*} value
 * @returns {boolean}
 */
export declare function isCtor(value: unknown): boolean;
/**
 * Capitalize.
 *
 * @param string
 */
export declare function capitalize(string: string): string;
/**
 * Clone deep.
 *
 * @param value
 */
export declare function cloneDeep<T>(value: T): T;
/**
 * Singularize.
 *
 * @param noun
 */
export declare function singularize(noun: string): string;
/**
 * Get ctor name.
 *
 * @param value
 */
export declare function getCtorName(value: unknown): string | undefined;
/**
 * Is pure object.
 *
 * @param value
 */
export declare function isPureObject(value: unknown): boolean;
/**
 * String to regexp.
 *
 * @param pattern
 * @param flags
 */
export declare function stringToRegexp(pattern: string | RegExp, flags?: string): RegExp;
/**
 * Get value by path.
 *
 * @param obj
 * @param path
 * @param orElse
 */
export declare function getValueByPath(obj: object, path: string, orElse?: unknown): unknown;
/**
 * Select object keys.
 *
 * @param obj
 * @param keys
 */
export declare function selectObjectKeys<T extends object>(obj: T, keys: string[]): Partial<T>;
/**
 * Exclude object keys.
 *
 * @param obj
 * @param keys
 */
export declare function excludeObjectKeys<T extends object>(obj: T, keys: string | string[]): Partial<T>;
/**
 * Filter.
 */
export declare type Filter = {
	where?: WhereClause;
	order?: OrderClause;
	limit?: number;
	skip?: number;
	fields?: FieldsClause;
	include?: IncludeClause;
};
/**
 * Item filter.
 */
export declare type ItemFilter = Pick<Filter, "fields" | "include">;
/**
 * Where clause.
 *
 * @example
 * ```ts
 * value => value.featured === true
 * {foo: 'bar'}
 * {foo: {eq: 'bar'}}
 * {foo: {neq: 'bar'}}
 * {foo: {gt: 5}}
 * {foo: {lt: 10}}
 * {foo: {gte: 5}}
 * {foo: {lte: 10}}
 * {foo: {inq: ['bar', 'baz']}}
 * {foo: {nin: ['bar', 'baz']}}
 * {foo: {between: [5, 10]}}
 * {foo: {exists: true}}
 * {foo: {like: 'bar'}}
 * {foo: {ilike: 'BaR'}}
 * {foo: {nlike: 'bar'}}
 * {foo: {nilike: 'BaR'}}
 * {foo: {regexp: 'ba.+'}}
 * {foo: {regexp: 'ba.+', flags: 'i'}}
 * {and: [...]}
 * {or: [...]}
 * ```
 */
export declare type WhereClause = FunctionClause | PropertiesClause | AndClause | OrClause;
/**
 * Function clause.
 *
 * @example
 * ```ts
 * (value) => value.featured === true;
 * ```
 */
export type FunctionClause = (value: ModelData) => boolean;
/**
 * Properties clause.
 *
 * @example
 * ```ts
 * {
 *   name: {inq: ['John', 'Mary']},
 *   status: 'ACTIVE',
 *   age: {gte: 40}
 * }
 * ```
 */
export type PropertiesClause = {
	[property: string]: OperatorClause | string | number | boolean | RegExp | null | undefined;
};
/**
 * Operator clause.
 *
 * @example
 * ```ts
 * {eq: 'bar'}
 * {neq: 'bar'}
 * {gt: 5}
 * {lt: 10}
 * {gte: 5}
 * {lte: 10}
 * {inq: ['bar', 'baz']}
 * {nin: ['bar', 'baz']}
 * {between: [5, 10]}
 * {exists: true}
 * {like: 'bar'}
 * {ilike: 'BaR'}
 * {nlike: 'bar'}
 * {nilike: 'BaR'}
 * {regexp: 'ba.+'}
 * {regexp: 'ba.+', flags: 'i'}
 * ```
 */
export declare type OperatorClause = {
	eq?: unknown;
	neq?: unknown;
	gt?: string | number;
	gte?: string | number;
	lt?: string | number;
	lte?: string | number;
	inq?: unknown[];
	nin?: unknown[];
	between?: readonly [
		string | number,
		string | number
	];
	exists?: boolean;
	like?: string | RegExp;
	nlike?: string | RegExp;
	ilike?: string | RegExp;
	nilike?: string | RegExp;
	regexp?: string | RegExp;
	flags?: string;
};
/**
 * And clause.
 *
 * @example
 * ```ts
 * {
 *   and: [...],
 * }
 * ```
 */
export interface AndClause {
	and: WhereClause[];
}
/**
 * Or clause.
 *
 * @example
 * ```ts
 * {
 *   or: [...],
 * }
 * ```
 */
export interface OrClause {
	or: WhereClause[];
}
/**
 * Order clause.
 *
 * @example
 * ```ts
 * 'prop'
 * 'prop ASC'
 * 'prop DESC';
 * ['prop1', 'prop2'];
 * ['prop1 ASC', 'prop2 DESC'];
 * ```
 */
export type OrderClause = string | string[];
/**
 * Fields.
 *
 * @example
 * ```ts
 * 'prop'
 * ['prop1', 'prop2']
 * ```
 */
export type FieldsClause = string | NormalizedFieldsClause;
/**
 * Normalized fields clause.
 *
 * @example
 * ```ts
 * [
 *   'prop1',
 *   'prop2',
 * ]
 * ```
 */
export type NormalizedFieldsClause = string[];
/**
 * Include clause.
 *
 * @example
 * ```ts
 * 'customers'
 * ```
 *
 * @example
 * ```ts
 * [
 *   'customers',
 *   'orders',
 * ]
 * ```
 *
 * @example
 * ```ts
 * {
 *   customer: 'orders'
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   customer: {
 *     address: 'city',
 *   },
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   customer: [
 *     'orders',
 *     {address: 'city'},
 *   ],
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   relation: 'customer',
 *   scope: {
 *     where: {removed: false},
 *     order: 'createdAt DESC',
 *     skip: 0,
 *     limit: 16,
 *     fields: ['id', 'name', 'removed'],
 *     include: 'address',
 *   }
 * }
 * ```
 */
export declare type IncludeClause = string | string[] | NestedIncludeClause | NestedIncludeClause[] | NormalizedIncludeClause | NormalizedIncludeClause[];
/**
 * Nested include clause.
 *
 * @example
 * ```ts
 * {
 *   customer: 'orders'
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   customer: {
 *     address: 'city',
 *   },
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   customer: [
 *     'orders',
 *     {address: 'city'},
 *   ],
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   relation: 'customer',
 *   scope: {
 *     where: {removed: false},
 *     order: 'createdAt DESC',
 *     skip: 0,
 *     limit: 16,
 *     fields: ['id', 'name', 'removed'],
 *     include: 'address',
 *   }
 * }
 * ```
 */
export declare type NestedIncludeClause = {
	[property: string]: IncludeClause;
};
/**
 * Inclusion.
 *
 * @example
 * ```ts
 * {
 *   relation: 'customer',
 * }
 * ```
 *
 * @example
 * ```ts
 * {
 *   relation: 'customer',
 *   scope: {
 *     where: {removed: false},
 *     order: 'createdAt DESC',
 *     skip: 0,
 *     limit: 16,
 *     fields: ['id', 'name', 'removed'],
 *     include: 'address',
 *   }
 * }
 * ```
 */
export declare type NormalizedIncludeClause = {
	relation: string;
	scope?: Filter;
};
/**
 * Slice clause tool.
 */
export declare class SliceClauseTool extends Service {
	/**
	 * Slice.
	 *
	 * @param entities
	 * @param skip
	 * @param limit
	 */
	slice(entities: ModelData[], skip?: number, limit?: number): ModelData[];
	/**
	 * Validate skip clause.
	 *
	 * @param skip
	 */
	static validateSkipClause(skip: number | undefined): void;
	/**
	 * Validate limit clause.
	 *
	 * @param limit
	 */
	static validateLimitClause(limit: number | undefined): void;
}
/**
 * Order clause tool.
 */
export declare class OrderClauseTool extends Service {
	/**
	 * Sort.
	 *
	 * @param entities
	 * @param clause
	 */
	sort(entities: ModelData[], clause: OrderClause | undefined): void;
	/**
	 * Validate order clause.
	 *
	 * @param clause
	 */
	static validateOrderClause(clause: OrderClause | undefined): void;
	/**
	 * Normalize order clause.
	 *
	 * @param clause
	 */
	static normalizeOrderClause(clause: OrderClause | undefined): string[] | undefined;
}
/**
 * Where clause tool.
 */
export declare class WhereClauseTool extends Service {
	/**
	 * Filter.
	 *
	 * @param entities
	 * @param where
	 */
	filter(entities: ModelData[], where: WhereClause | undefined): ModelData[];
	/**
	 * Validate where clause.
	 *
	 * @param clause
	 */
	static validateWhereClause(clause: WhereClause | undefined): void;
}
/**
 * Field clause tool.
 */
export declare class FieldsClauseTool extends Service {
	/**
	 * Filter.
	 *
	 * @param entities
	 * @param modelName
	 * @param clause
	 */
	filter<T extends ModelData | ModelData[]>(entities: T, modelName: string, clause: FieldsClause | undefined): T;
	/**
	 * Validate fields clause.
	 *
	 * @param clause
	 */
	static validateFieldsClause(clause: FieldsClause | undefined): void;
	/**
	 * Normalize fields clause.
	 *
	 * @param clause
	 */
	static normalizeFieldsClause(clause: FieldsClause | undefined): NormalizedFieldsClause | undefined;
}
/**
 * Include clause tool.
 */
export declare class IncludeClauseTool extends Service {
	/**
	 * Include to.
	 *
	 * @param entities
	 * @param modelName
	 * @param clause
	 */
	includeTo(entities: ModelData[], modelName: string, clause: IncludeClause | undefined): Promise<void>;
	/**
	 * Validate include clause.
	 *
	 * @param clause
	 */
	static validateIncludeClause(clause: IncludeClause | undefined): void;
	/**
	 * Validate scope clause.
	 *
	 * @param clause
	 */
	static validateScopeClause(clause: Filter | undefined): void;
	/**
	 * Normalize include clause.
	 *
	 * @param clause
	 */
	static normalizeIncludeClause(clause: IncludeClause | undefined): NormalizedIncludeClause[];
	/**
	 * Normalize scope clause.
	 *
	 * @param clause
	 */
	static normalizeScopeClause(clause: Filter | undefined): Filter | undefined;
}
/**
 * Operator clause tool.
 */
export declare class OperatorClauseTool extends Service {
	/**
	 * Compare.
	 *
	 * @param val1
	 * @param val2
	 */
	compare(val1: unknown, val2: unknown): number;
	/**
	 * Test all operators.
	 *
	 * @param clause
	 * @param value
	 */
	testAll(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test eq/neq operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   eq: 'foo',
	 * }
	 * ```
	 *
	 * @example
	 * ```ts
	 * {
	 *   neq: 'foo',
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testEqNeq(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test lt/gt/lte/gte operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   lt: 10,
	 * }
	 * ```
	 *
	 * @example
	 * ```ts
	 * {
	 *   lte: 10,
	 * }
	 * ```
	 *
	 * @example
	 * ```ts
	 * {
	 *   gt: 10,
	 * }
	 * ```
	 *
	 * @example
	 * ```ts
	 * {
	 *   gte: 10,
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testGtLt(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test inc operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   inc: ['foo', 'bar'],
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testInq(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test nin operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   nin: ['foo', 'bar'],
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testNin(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test between operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   between: [10, 20],
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testBetween(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test exists operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   exists: true,
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testExists(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test like operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   like: 'foo',
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testLike(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test nlike operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   nlike: 'foo',
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testNlike(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test ilike operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   ilike: 'foo',
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testIlike(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test nilike operator.
	 *
	 * @example
	 * ```ts
	 * {
	 *   nilike: 'foo',
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testNilike(clause: object, value: unknown): boolean | undefined;
	/**
	 * Test regexp.
	 *
	 * @example
	 * ```ts
	 * {
	 *   regexp: 'foo.*',
	 * }
	 * ```
	 *
	 * @example
	 * ```ts
	 * {
	 *   regexp: 'foo.*',
	 *   flags: 'i',
	 * }
	 * ```
	 *
	 * @param clause
	 * @param value
	 */
	testRegexp(clause: object, value: unknown): boolean | undefined;
}
/**
 * Adapter.
 */
export declare class Adapter extends Service {
	/**
	 * Settings.
	 */
	get settings(): AnyObject | undefined;
	/**
	 * Constructor.
	 *
	 * @param container
	 * @param settings
	 */
	constructor(container?: ServiceContainer, settings?: AnyObject);
	/**
	 * Create.
	 *
	 * @param modelName
	 * @param modelData
	 * @param filter
	 */
	create(modelName: string, modelData: ModelData, filter?: ItemFilter): Promise<ModelData>;
	/**
	 * Replace by id.
	 *
	 * @param modelName
	 * @param id
	 * @param modelData
	 * @param filter
	 */
	replaceById(modelName: string, id: ModelId, modelData: ModelData, filter?: ItemFilter): Promise<ModelData>;
	/**
	 * Patch by id.
	 *
	 * @param modelName
	 * @param id
	 * @param modelData
	 * @param filter
	 */
	patchById(modelName: string, id: ModelId, modelData: ModelData, filter?: ItemFilter): Promise<ModelData>;
	/**
	 * Find.
	 *
	 * @param modelName
	 * @param filter
	 */
	find(modelName: string, filter?: Filter): Promise<ModelData[]>;
	/**
	 * Find by id.
	 *
	 * @param modelName
	 * @param id
	 * @param filter
	 */
	findById(modelName: string, id: ModelId, filter?: Filter): Promise<ModelData>;
	/**
	 * Delete.
	 *
	 * @param modelName
	 * @param where
	 */
	delete(modelName: string, where?: WhereClause): Promise<number>;
	/**
	 * Delete by id.
	 *
	 * @param modelName
	 * @param id
	 */
	deleteById(modelName: string, id: ModelId): Promise<boolean>;
	/**
	 * Exists.
	 *
	 * @param modelName
	 * @param id
	 */
	exists(modelName: string, id: ModelId): Promise<boolean>;
	/**
	 * Count.
	 *
	 * @param modelName
	 * @param where
	 */
	count(modelName: string, where?: WhereClause): Promise<number>;
}
/**
 * Adapter loader.
 */
export declare class AdapterLoader extends Service {
	/**
	 * Load by name.
	 *
	 * @param adapterName
	 * @param settings
	 */
	loadByName(adapterName: string, settings?: AnyObject): Promise<Adapter>;
}
/**
 * Adapter registry.
 */
export declare class AdapterRegistry extends Service {
	/**
	 * Get adapter.
	 *
	 * @param datasourceName
	 */
	getAdapter(datasourceName: string): Promise<Adapter>;
}
/**
 * Relation type.
 */
export declare enum RelationType {
	BELONGS_TO = "belongsTo",
	HAS_ONE = "hasOne",
	HAS_MANY = "hasMany",
	REFERENCES_MANY = "referencesMany"
}
/**
 * Relation definition.
 *
 * @example Available options.
 * ```ts
 * {
 *   type: RelationType;
 *   model?: string;
 *   foreignKey?: string;
 *   polymorphic?: boolean | string;
 *   discriminator?: string;
 * }
 * ```
 */
export declare type RelationDefinition = 
// belongsTo
BelongsToDefinition | PolyBelongsToDefinition
// hasOne
 | HasOneDefinition | PolyHasOneDefinitionWithTargetRelationName | PolyHasOneDefinitionWithTargetKeys
// hasMany
 | HasManyDefinition | PolyHasManyDefinitionWithTargetRelationName | PolyHasManyDefinitionWithTargetKeys
// referencesMany
 | ReferencesManyDefinition;
/**
 * The regular "belongsTo" relation.
 *
 * @example Required options only.
 * ```
 * {
 *   type: RelationType.BELONGS_TO,
 *   model: 'model',
 * }
 * ```
 *
 * @example Verbose definition.
 * ```
 * {
 *   type: RelationType.BELONGS_TO,
 *   model: 'model',
 *   foreignKey: 'modelId',
 * }
 * ```
 */
export declare type BelongsToDefinition = {
	type: RelationType.BELONGS_TO;
	polymorphic?: false;
	model: string;
	foreignKey?: string;
};
/**
 * The polymorphic "belongsTo" relation.
 *
 * @example Required fields only.
 * ```
 * {
 *   type: RelationType.BELONGS_TO,
 *   polymorphic: true,
 * }
 * ```
 *
 * @example Verbose definition.
 * ```
 * {
 *   type: RelationType.BELONGS_TO,
 *   polymorphic: true,
 *   foreignKey: 'referenceId',
 *   discriminator: 'referenceType,
 * }
 * ```
 */
export declare type PolyBelongsToDefinition = {
	type: RelationType.BELONGS_TO;
	polymorphic: true;
	foreignKey?: string;
	discriminator?: string;
};
/**
 * The regular "hasOne" relation.
 *
 * @example
 * ```ts
 * {
 *   type: RelationType.HAS_ONE,
 *   model: 'model',
 *   foreignKey: 'modelId',
 * }
 * ```
 */
export declare type HasOneDefinition = {
	type: RelationType.HAS_ONE;
	model: string;
	polymorphic?: false;
	foreignKey?: string;
	discriminator?: undefined;
};
/**
 * The polymorphic "hasOne" relation with a target relation name.
 *
 * @example
 * ```ts
 * {
 *   type: RelationType.HAS_ONE,
 *   model: 'model',
 *   polymorphic: 'reference',
 * }
 * ```
 */
export declare type PolyHasOneDefinitionWithTargetRelationName = {
	type: RelationType.HAS_ONE;
	model: string;
	polymorphic: string;
	foreignKey?: undefined;
	discriminator?: undefined;
};
/**
 * The polymorphic "hasOne" relation with target relation keys.
 *
 * @example Required options only.
 * ```
 * {
 *   type: RelationType.HAS_ONE,
 *   model: 'model',
 *   polymorphic: true,
 * }
 * ```
 *
 * @example Verbose definition.
 * ```
 * {
 *   type: RelationType.HAS_ONE,
 *   model: 'model',
 *   polymorphic: true,
 *   foreignKey: 'referenceId',
 *   discriminator: 'referenceType,
 * }
 * ```
 */
export declare type PolyHasOneDefinitionWithTargetKeys = {
	type: RelationType.HAS_ONE;
	model: string;
	polymorphic: true;
	foreignKey?: string;
	discriminator?: string;
};
/**
 * The regular "hasMany" relation.
 *
 * @example
 * ```ts
 * {
 *   type: RelationType.HAS_MANY,
 *   model: 'model',
 *   foreignKey: 'modelId',
 * }
 * ```
 */
export declare type HasManyDefinition = {
	type: RelationType.HAS_MANY;
	model: string;
	polymorphic?: false;
	foreignKey?: string;
	discriminator?: undefined;
};
/**
 * The polymorphic "hasMany" relation with a target relation name.
 *
 * @example
 * ```ts
 * {
 *   type: RelationType.HAS_MANY,
 *   model: 'model',
 *   polymorphic: 'reference',
 * }
 * ```
 */
export declare type PolyHasManyDefinitionWithTargetRelationName = {
	type: RelationType.HAS_MANY;
	model: string;
	polymorphic: string;
	foreignKey?: undefined;
	discriminator?: undefined;
};
/**
 * The polymorphic "hasMany" relation with target relation keys.
 *
 * @example Required options only.
 * ```
 * {
 *   type: RelationType.HAS_MANY,
 *   model: 'model',
 *   polymorphic: true,
 * }
 * ```
 *
 * @example Verbose definition.
 * ```
 * {
 *   type: RelationType.HAS_MANY,
 *   model: 'model',
 *   polymorphic: true,
 *   foreignKey: 'referenceId',
 *   discriminator: 'referenceType,
 * }
 * ```
 */
export declare type PolyHasManyDefinitionWithTargetKeys = {
	type: RelationType.HAS_MANY;
	model: string;
	polymorphic: true;
	foreignKey?: string;
	discriminator?: string;
};
/**
 * The regular "referencesMany" relation.
 *
 * @example Required options only.
 * ```
 * {
 *   type: RelationType.REFERENCES_MANY,
 *   model: 'model',
 * }
 * ```
 *
 * @example Verbose definition.
 * ```
 * {
 *   type: RelationType.REFERENCES_MANY,
 *   model: 'model',
 *   foreignKey: 'modelIds',
 * }
 * ```
 */
export declare type ReferencesManyDefinition = {
	type: RelationType.REFERENCES_MANY;
	model: string;
	foreignKey?: string;
	discriminator?: undefined;
};
/**
 * Data type.
 */
export declare enum DataType {
	ANY = "any",
	STRING = "string",
	NUMBER = "number",
	BOOLEAN = "boolean",
	ARRAY = "array",
	OBJECT = "object"
}
/**
 * Full property definition.
 */
export declare type FullPropertyDefinition = {
	type: DataType;
	itemType?: DataType;
	model?: string;
	primaryKey?: boolean;
	columnName?: string;
	columnType?: string;
	required?: boolean;
	default?: unknown;
};
/**
 * Property definition.
 */
export declare type PropertyDefinition = DataType | FullPropertyDefinition;
/**
 * Properties definition validator.
 */
export declare class PropertiesDefinitionValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param modelName
	 * @param propDefs
	 */
	validate(modelName: string, propDefs: PropertyDefinitionMap): void;
}
/**
 * Primary keys definition validator.
 */
export declare class PrimaryKeysDefinitionValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param modelName
	 * @param propDefs
	 */
	validate(modelName: string, propDefs: PropertyDefinitionMap): void;
}
/**
 * Default values definition validator.
 */
export declare class DefaultValuesDefinitionValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param modelName
	 * @param propDefs
	 */
	validate(modelName: string, propDefs: PropertyDefinitionMap): void;
}
/**
 * Property definition map.
 */
export declare type PropertyDefinitionMap = {
	[name: string]: PropertyDefinition;
};
/**
 * Relation definition map.
 */
export declare type RelationDefinitionMap = {
	[name: string]: RelationDefinition;
};
/**
 * Model definition.
 */
export declare type ModelDefinition = {
	name: string;
	datasource?: string;
	base?: string;
	tableName?: string;
	properties?: PropertyDefinitionMap;
	relations?: RelationDefinitionMap;
};
/**
 * Relations definition validator.
 */
export declare class RelationsDefinitionValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param modelName
	 * @param relDefs
	 */
	validate(modelName: string, relDefs: RelationDefinitionMap): void;
}
/**
 * Model data validator.
 */
export declare class ModelDataValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param modelName
	 * @param modelData
	 * @param isPartial
	 */
	validate(modelName: string, modelData: ModelData, isPartial?: boolean): void;
	/**
	 * Validate property value.
	 *
	 * @param modelName
	 * @param propName
	 * @param propDef
	 * @param propValue
	 */
	validatePropertyValue(modelName: string, propName: string, propDef: PropertyDefinition, propValue: unknown): void;
}
/**
 * Model data sanitizer.
 */
export declare class ModelDataSanitizer extends Service {
	/**
	 * Sanitize.
	 *
	 * @param modelName
	 * @param modelData
	 */
	sanitize(modelName: string, modelData: ModelData): ModelData;
}
/**
 * Default primary key property name.
 */
export type DEFAULT_PRIMARY_KEY_PROPERTY_NAME = "id";
/**
 * Model definition utils.
 */
export declare class ModelDefinitionUtils extends Service {
	/**
	 * Get primary key as property name.
	 *
	 * @param modelName
	 */
	getPrimaryKeyAsPropertyName(modelName: string): string;
	/**
	 * Get primary key as column name.
	 *
	 * @param modelName
	 */
	getPrimaryKeyAsColumnName(modelName: string): string;
	/**
	 * Get table name by model name.
	 *
	 * @param modelName
	 */
	getTableNameByModelName(modelName: string): string;
	/**
	 * Get column name by property name.
	 *
	 * @param modelName
	 * @param propertyName
	 */
	getColumnNameByPropertyName(modelName: string, propertyName: string): string;
	/**
	 * Get default property value.
	 *
	 * @param modelName
	 * @param propertyName
	 */
	getDefaultPropertyValue(modelName: string, propertyName: string): unknown;
	/**
	 * Set default values to empty properties.
	 *
	 * @param modelName
	 * @param modelData
	 * @param onlyProvidedProperties
	 */
	setDefaultValuesToEmptyProperties<T extends ModelData>(modelName: string, modelData: T, onlyProvidedProperties?: boolean): T;
	/**
	 * Convert property names to column names.
	 *
	 * @param modelName
	 * @param modelData
	 */
	convertPropertyNamesToColumnNames(modelName: string, modelData: ModelData): ModelData;
	/**
	 * Convert column names to property names.
	 *
	 * @param modelName
	 * @param tableData
	 */
	convertColumnNamesToPropertyNames(modelName: string, tableData: ModelData): ModelData;
	/**
	 * Get data type by property name.
	 *
	 * @param modelName
	 * @param propertyName
	 */
	getDataTypeByPropertyName(modelName: string, propertyName: string): DataType;
	/**
	 * Get own properties definition of primary keys.
	 *
	 * @param modelName
	 */
	getOwnPropertiesDefinitionOfPrimaryKeys(modelName: string): PropertyDefinitionMap;
	/**
	 * Get own properties definition without primary keys.
	 *
	 * @param modelName
	 */
	getOwnPropertiesDefinitionWithoutPrimaryKeys(modelName: string): PropertyDefinitionMap;
	/**
	 * Get properties definition in base model hierarchy.
	 *
	 * @param modelName
	 */
	getPropertiesDefinitionInBaseModelHierarchy(modelName: string): PropertyDefinitionMap;
	/**
	 * Get own relations definition.
	 *
	 * @param modelName
	 */
	getOwnRelationsDefinition(modelName: string): RelationDefinitionMap;
	/**
	 * Get relations definition in base model hierarchy.
	 *
	 * @param modelName
	 */
	getRelationsDefinitionInBaseModelHierarchy(modelName: string): RelationDefinitionMap;
	/**
	 * Get relation definition by name.
	 *
	 * @param modelName
	 * @param relationName
	 */
	getRelationDefinitionByName(modelName: string, relationName: string): RelationDefinition;
	/**
	 * Exclude object keys by relation names.
	 *
	 * @param modelName
	 * @param modelData
	 */
	excludeObjectKeysByRelationNames<T extends ModelData>(modelName: string, modelData: T): Partial<T>;
}
/**
 * Model definition validator.
 */
export declare class ModelDefinitionValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param modelDef
	 */
	validate(modelDef: ModelDefinition): void;
}
/**
 * Datasource definition.
 */
export declare type DatasourceDefinition = {
	name: string;
	adapter: string;
};
/**
 * Datasource definition validator.
 */
export declare class DatasourceDefinitionValidator extends Service {
	/**
	 * Validate.
	 *
	 * @param datasourceDef
	 */
	validate(datasourceDef: DatasourceDefinition): void;
}
/**
 * Definition registry.
 */
export declare class DefinitionRegistry extends Service {
	/**
	 * Add datasource.
	 *
	 * @param datasourceDef
	 */
	addDatasource(datasourceDef: DatasourceDefinition): void;
	/**
	 * Has datasource.
	 *
	 * @param name
	 */
	hasDatasource(name: string): boolean;
	/**
	 * Get datasource.
	 *
	 * @param name
	 */
	getDatasource(name: string): DatasourceDefinition;
	/**
	 * Add model.
	 *
	 * @param modelDef
	 */
	addModel(modelDef: ModelDefinition): void;
	/**
	 * Has model.
	 *
	 * @param name
	 */
	hasModel(name: string): boolean;
	/**
	 * Get model.
	 *
	 * @param name
	 */
	getModel(name: string): ModelDefinition;
}
/**
 * Repository.
 */
export declare class Repository<Data extends ModelData = ModelData, IdType extends ModelId = ModelId, IdName extends string = DEFAULT_PRIMARY_KEY_PROPERTY_NAME, FlatData extends ModelData = Flatten<Data>> extends Service {
	/**
	 * Model name.
	 */
	get modelName(): string;
	/**
	 * Datasource name.
	 */
	get datasourceName(): string;
	/**
	 * Constructor.
	 *
	 * @param container
	 * @param modelName
	 */
	constructor(container: ServiceContainer, modelName: string);
	/**
	 * Get adapter.
	 */
	getAdapter(): Promise<Adapter>;
	/**
	 * Create.
	 *
	 * @param data
	 * @param filter
	 */
	create(data: OptionalUnlessRequiredId<IdName, FlatData>, filter?: ItemFilter): Promise<FlatData>;
	/**
	 * Replace by id.
	 *
	 * @param id
	 * @param data
	 * @param filter
	 */
	replaceById(id: IdType, data: WithoutId<IdName, FlatData>, filter?: ItemFilter): Promise<FlatData>;
	/**
	 * Replace or create.
	 *
	 * @param data
	 * @param filter
	 */
	replaceOrCreate(data: OptionalUnlessRequiredId<IdName, Data>, filter?: ItemFilter): Promise<FlatData>;
	/**
	 * Patch by id.
	 *
	 * @param id
	 * @param data
	 * @param filter
	 */
	patchById(id: IdType, data: PartialWithoutId<IdName, Data>, filter?: ItemFilter): Promise<FlatData>;
	/**
	 * Find.
	 *
	 * @param filter
	 */
	find(filter?: Filter): Promise<FlatData[]>;
	/**
	 * Find one.
	 *
	 * @param filter
	 */
	findOne(filter?: ItemFilter): Promise<FlatData | undefined>;
	/**
	 * Find by id.
	 *
	 * @param id
	 * @param filter
	 */
	findById(id: IdType, filter?: ItemFilter): Promise<FlatData>;
	/**
	 * Delete.
	 *
	 * @param where
	 */
	delete(where?: WhereClause): Promise<number>;
	/**
	 * Delete by id.
	 *
	 * @param id
	 */
	deleteById(id: IdType): Promise<boolean>;
	/**
	 * Exists.
	 *
	 * @param id
	 */
	exists(id: IdType): Promise<boolean>;
	/**
	 * Count.
	 *
	 * @param where
	 */
	count(where?: WhereClause): Promise<number>;
}
/**
 * Removes id field.
 */
export type WithoutId<IdName extends string, Data extends ModelData> = Flatten<Omit<Data, IdName>>;
/**
 * Makes fields as optional and remove id field.
 */
export type PartialWithoutId<IdName extends string, Data extends ModelData> = Flatten<Partial<Omit<Data, IdName>>>;
/**
 * Makes the required id field as optional.
 */
export type OptionalUnlessRequiredId<IdName extends string, Data extends ModelData> = Flatten<Data extends {
	[K in IdName]: any;
} ? PartialBy<Data, IdName> : Data>;
/**
 * Repository registry.
 */
export declare class RepositoryRegistry extends Service {
	/**
	 * Set repository registry.
	 *
	 * @param ctor
	 */
	setRepositoryCtor(ctor: Constructor<Repository<any, any, any>>): void;
	/**
	 * Get repository.
	 *
	 * @param modelName
	 */
	getRepository<Data extends ModelData = ModelData, IdType extends ModelId = ModelId, IdName extends string = DEFAULT_PRIMARY_KEY_PROPERTY_NAME>(modelName: string): Repository<Data, IdType, IdName>;
}
/**
 * Schema.
 */
export declare class Schema extends Service {
	/**
	 * Define datasource.
	 *
	 * @param datasourceDef
	 */
	defineDatasource(datasourceDef: DatasourceDefinition): this;
	/**
	 * Define model.
	 *
	 * @param modelDef
	 */
	defineModel(modelDef: ModelDefinition): this;
	/**
	 * Get repository.
	 *
	 * @param modelName
	 */
	getRepository<Data extends ModelData = ModelData, IdType extends ModelId = ModelId, IdName extends string = DEFAULT_PRIMARY_KEY_PROPERTY_NAME>(modelName: string): Repository<Data, IdType, IdName>;
}
/**
 * Not implemented error.
 */
export declare class NotImplementedError extends Errorf {
}
/**
 * Invalid argument error.
 */
export declare class InvalidArgumentError extends Errorf {
}
/**
 * Invalid operator value error.
 */
export declare class InvalidOperatorValueError extends Error {
	/**
	 * Constructor.
	 *
	 * @param operator
	 * @param expects
	 * @param value
	 */
	constructor(operator: string, expects: string, value: unknown);
}
/**
 * Has one resolver.
 */
export declare class HasOneResolver extends Service {
	/**
	 * Include to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param foreignKey
	 * @param scope
	 */
	includeTo(entities: ModelData[], sourceName: string, targetName: string, relationName: string, foreignKey: string, scope?: Filter): Promise<void>;
	/**
	 * Include polymorphic to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param foreignKey
	 * @param discriminator
	 * @param scope
	 */
	includePolymorphicTo(entities: ModelData[], sourceName: string, targetName: string, relationName: string, foreignKey: string, discriminator: string, scope?: Filter): Promise<void>;
	/**
	 * Include polymorphic by relation name.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param targetRelationName
	 * @param scope
	 */
	includePolymorphicByRelationName(entities: ModelData[], sourceName: string, targetName: string, relationName: string, targetRelationName: string, scope?: Filter): Promise<void>;
}
/**
 * Has many resolver.
 */
export declare class HasManyResolver extends Service {
	/**
	 * Include to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param foreignKey
	 * @param scope
	 */
	includeTo(entities: ModelData[], sourceName: string, targetName: string, relationName: string, foreignKey: string, scope?: Filter): Promise<void>;
	/**
	 * Include polymorphic to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param foreignKey
	 * @param discriminator
	 * @param scope
	 */
	includePolymorphicTo(entities: ModelData[], sourceName: string, targetName: string, relationName: string, foreignKey: string, discriminator: string, scope?: Filter): Promise<void>;
	/**
	 * Include polymorphic by relation name.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param targetRelationName
	 * @param scope
	 */
	includePolymorphicByRelationName(entities: ModelData[], sourceName: string, targetName: string, relationName: string, targetRelationName: string, scope?: Filter): Promise<void>;
}
/**
 * Belongs to resolver.
 */
export declare class BelongsToResolver extends Service {
	/**
	 * Include to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param foreignKey
	 * @param scope
	 */
	includeTo(entities: ModelData[], sourceName: string, targetName: string, relationName: string, foreignKey?: string, scope?: Filter): Promise<void>;
	/**
	 * Include polymorphic to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param relationName
	 * @param foreignKey
	 * @param discriminator
	 * @param scope
	 */
	includePolymorphicTo(entities: ModelData[], sourceName: string, relationName: string, foreignKey?: string, discriminator?: string, scope?: Filter): Promise<void>;
}
/**
 * References many resolver.
 */
export declare class ReferencesManyResolver extends Service {
	/**
	 * Include to.
	 *
	 * @param entities
	 * @param sourceName
	 * @param targetName
	 * @param relationName
	 * @param foreignKey
	 * @param scope
	 */
	includeTo(entities: ModelData[], sourceName: string, targetName: string, relationName: string, foreignKey?: string, scope?: Filter): Promise<void>;
}

export {};
